---
title: JS手写题
author: DBAAZzz
date: 2025/12/30 23:10
categories:
  - 面试
---

# JS 手写题

## 手写 call

```js
Function.prototype.myCall = function (context, ...args) {
  context = context || window;

  const fn = Symbol();

  // 获取当前函数
  context[fn] = this;
  const resutl = context[fn](...args);
  delete context[fn];
  return result;
};
```

## 手写 apply

```js
Function.prototype.myApply = function (context, args) {
  context = context || window;

  const fn = Symbol();
  context[fn] = this;

  const result = args ? context[fn](...args) : context[fn]();
  return result;
};
```

## 手写 bind

```js
Function.protorype.myBind = function (context, ...args) {
  const fn = this;

  function boundFunction(...newArgs) {
    // 判断是否通过 new 调用
    return fn.apply(this instanceof boundFunction ? this : context, [
      ...args,
      ...newArgs,
    ]);
  }

  // 继承原函数里的原型链
  boundFunction.prototype = Object.create(fn.prototype);
  return boundFunction;
};
```

## 手写 instanceof

```js
/**
 * 手写 instanceof 实现
 * instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
 */
function myInstanceof(obj, constructor) {
  if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
    return false;
  }

  // 获取构造函数的原型对象
  const protorype = constructor.protorype;

  // Object.getPrototypeOf(obj) 等同于 obj.__proto__
  const proto = Object.getPrototypeOf(obj);

  while (proto) {
    if (proto == protorype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  return false;
}
```

## 手写 new

```js
function myNew(constructor, ...args) {
  // 参数校验，构造函数必须是函数类型
  if (typeof constructor !== "function") {
    return new Error("必须是函数");
  }

  // 创建一个新对象，并将其原型指向构造函数的 prototype
  const instance = Object.create(constructor.prototype);

  // 执行构造函数，将 this 绑定到新对象
  const result = constructor.apply(instance, args);

  // 如果构造函数返回的是对象，则返回该对象；否则返回新创建的对象
  return (result !== null && typeof result === "object") ||
    typeof result === "function"
    ? result
    : instance;
}
```

## 手写 Promise 的 race、all

```js
// 手写 Promise 的 race、all

class Promise {
  static race(promises) {
    return new Promise((resolve, reject) => {
      for (let i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i])
        .then((res) => {
          resolve(res)
        }).catch(err) {
          reject(err)
        }
      }
    })
  }

  static all(promises) {
    return new Promise((resolve, reject) => {
      let result = []
      let index = 0

      for (let i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i])
          .then((res) => {
            result[i] = res
            index++
            if (index === promises.length) {
              resolve(result)
            }
          })
          .catch((err) => {
            reject(err)
          })
      }
    })
  }
}
```

## 手写并发控制器、请求池、并发调度器

实现一个函数，能够：

- 同时最多执行 N 个异步任务
- 当有任务完成后，自动从队列中取出下一个任务执行
- 所有任务完成后返回结果

```js
class controller {
  constructor(limit) {
    this.limit = limit;
    this.running = 0;
    this.queue = [];
  }

  async add(fn) {
    if (this.running >= this.limit) {
      await new Promise((resolve) => {
        this.queue.push(resolve);
      });
    }

    this.running++;
    try {
      const result = await fn();
      return result;
    } finally {
      this.running--;
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }

  addAll(tasks) {
    const promises = tasks.map((task) => this.add(task));
    return Promise.all(promises);
  }
}
```
