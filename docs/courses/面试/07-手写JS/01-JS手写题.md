---
title: JS手写题
author: DBAAZzz
date: 2025/12/30 23:10
categories:
  - 面试
---

# JS 手写题

## 手写 call

```js
Function.prototype.myCall = function (context, ...args) {
  context = context || window;

  const fn = Symbol();

  // 获取当前函数
  context[fn] = this;
  const resutl = context[fn](...args);
  delete context[fn];
  return result;
};
```

## 手写 apply

```js
Function.prototype.myApply = function (context, args) {
  context = context || window;

  const fn = Symbol();
  context[fn] = this;

  const result = args ? context[fn](...args) : context[fn]();
  return result;
};
```

## 手写 bind

```js
Function.protorype.myBind = function (context, ...args) {
  const fn = this;

  function boundFunction(...newArgs) {
    // 判断是否通过 new 调用
    return fn.apply(this instanceof boundFunction ? this : context, [
      ...args,
      ...newArgs,
    ]);
  }

  // 继承原函数里的原型链
  boundFunction.prototype = Object.create(fn.prototype);
  return boundFunction;
};
```

## 手写 instanceof

```js
/**
 * 手写 instanceof 实现
 * instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
 */
function myInstanceof(obj, constructor) {
  if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
    return false;
  }

  // 获取构造函数的原型对象
  const protorype = constructor.protorype;

  // Object.getPrototypeOf(obj) 等同于 obj.__proto__
  const proto = Object.getPrototypeOf(obj);

  while (proto) {
    if (proto == protorype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  return false;
}
```

## 手写 new

```js
function myNew(constructor, ...args) {
  // 参数校验，构造函数必须是函数类型
  if (typeof constructor !== "function") {
    return new Error("必须是函数");
  }

  // 创建一个新对象，并将其原型指向构造函数的 prototype
  const instance = Object.create(constructor.prototype);

  // 执行构造函数，将 this 绑定到新对象
  const result = constructor.apply(instance, args);

  // 如果构造函数返回的是对象，则返回该对象；否则返回新创建的对象
  return (result !== null && typeof result === "object") ||
    typeof result === "function"
    ? result
    : instance;
}
```

## 手写 Promise 的 race、all

```js
// 手写 Promise 的 race、all

class Promise {
  static race(promises) {
    return new Promise((resolve, reject) => {
      for (let i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i])
        .then((res) => {
          resolve(res)
        }).catch(err) {
          reject(err)
        }
      }
    })
  }

  static all(promises) {
    return new Promise((resolve, reject) => {
      let result = []
      let index = 0

      for (let i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i])
          .then((res) => {
            result[i] = res
            index++
            if (index === promises.length) {
              resolve(result)
            }
          })
          .catch((err) => {
            reject(err)
          })
      }
    })
  }
}
```

## 手写并发控制器、请求池、并发调度器

实现一个函数，能够：

- 同时最多执行 N 个异步任务
- 当有任务完成后，自动从队列中取出下一个任务执行
- 所有任务完成后返回结果

```js
class controller {
  constructor(limit) {
    this.limit = limit;
    this.running = 0;
    this.queue = [];
  }

  async add(fn) {
    if (this.running >= this.limit) {
      await new Promise((resolve) => {
        this.queue.push(resolve);
      });
    }

    this.running++;
    try {
      const result = await fn();
      return result;
    } finally {
      this.running--;
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }

  addAll(tasks) {
    const promises = tasks.map((task) => this.add(task));
    return Promise.all(promises);
  }
}
```

## JS 沙箱实现

### Proxy 沙箱

```js
const createSandbox = function (context, whitelist = []) {
  const handler = {
    has(target, key) {
      // 直接返回 true！
      // 意思是：不管代码找什么变量（哪怕是 window），我都骗 with 说“我有这个变量”。
      // 这样 with 就永远不会去外层全局作用域查找了。
      return true;
    },
    getter(target, key) {
      // Symbol.unscopables 只在with作用域中生效， 用于指定哪些属性在 with 的作用域中应该被“屏蔽”
      if (key === Symbol.unscopables) {
        return undefined;
      }

      if (!whitelist.includes(key)) {
        throw new Error("禁止访问，不在白名单内");
      }

      return Reflect.get(context, key);
    },
  };
};

// 1. 定义我们允许用户访问的工具（白名单）
const allowedVars = ["console", "Math", "mySafeData"];

// 2. 准备实际数据
const contextData = {
  console: console,
  Math: Math,
  mySafeData: "我是安全的数据",
  // 注意：这里虽然有 secret，但如果没加进 allowedVars，用户也拿不到
  secret: "我是机密数据",
};

// 3. 创建沙箱
const proxyScope = createWhitelistSandbox(contextData, allowedVars);

// 4. 模拟恶意代码
const userCode = `
    // 1. 尝试访问允许的
    console.log('Math.PI:', Math.PI);
    console.log('数据:', mySafeData);

    // 2. 尝试访问未授权的内部变量
    try {
        console.log(secret);
    } catch(e) {
        console.error(e.message);
    }

    // 3. 尝试访问全局 window
    try {
        console.log(window);
    } catch(e) {
        console.error(e.message);
    }
`;

const run = new Function("scope", `with(scope) { ${userCode} }`);
run(proxyScope);
```

### iframe 实现

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>Iframe JS Sandbox</title>
  </head>
  <body>
    <button id="run">Run Sandbox Code</button>

    <script>
      function createIframeSandbox() {
        const iframe = document.createElement("iframe");
        iframe.sandbox = "allow-scripts";
        iframe.src = "about:blank";
        iframe.style.display = "none";
        document.body.appendChild(iframe);

        iframe.onload = () => {
          const doc = iframe.contentDocument;
          const script = doc.createElement("script");

          script.textContent = `
          window.addEventListener('message', (e) => {
            const { code } = e.data || {}
            if (!code) return
            try {
              const result = (new Function(code))()
              parent.postMessage({ type: 'result', result }, '*')
            } catch (err) {
              parent.postMessage({ type: 'error', error: err.message }, '*')
            }
          })
        `;
          doc.body.appendChild(script);
        };

        return {
          run(code) {
            iframe.contentWindow.postMessage({ code }, "*");
          },
          destroy() {
            iframe.remove();
          },
        };
      }

      const sandbox = createIframeSandbox();

      window.addEventListener("message", (e) => {
        if (e.data?.type === "result") {
          console.log("Sandbox result:", e.data.result);
        }
        if (e.data?.type === "error") {
          console.error("Sandbox error:", e.data.error);
        }
      });

      document.getElementById("run").onclick = () => {
        sandbox.run(`
        window.a = 1
        window.b = 2
        a + b
      `);
      };
    </script>
  </body>
</html>
```
