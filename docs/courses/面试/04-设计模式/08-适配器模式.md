---
title: 适配器模式
author: DBAAZzz
date: 2025/11/30 23:30
categories:
  - 面试
tags:
  - 设计模式
  - 适配器模式
---

## 适配器模式

**适配器模式**（Adapter Pattern）作为两个不兼容接口之间的桥梁。它将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

核心思想：

- **转换接口**：将旧接口转换为新接口，或将第三方接口转换为标准接口
- **兼容性**：解决现有系统与第三方库或旧系统的兼容问题
- **复用性**：复用现有的功能，而不需要修改原有代码

适配器模式属于**结构型模式**。生活中最常见的例子就是电源适配器、USB 转接头。

## 基本实现

假设我们有一个旧的计算器类，和一个新的系统，新系统调用的方法名与旧的不一致。

```javascript
// 旧接口：被适配者
class OldCalculator {
  constructor() {
    this.name = 'Old Calculator'
  }

  operation(t1, t2, operation) {
    switch (operation) {
      case 'add':
        return t1 + t2
      case 'sub':
        return t1 - t2
      default:
        return NaN
    }
  }
}

// 新接口：目标接口
class NewCalculator {
  constructor() {
    this.name = 'New Calculator'
  }

  add(t1, t2) {
    return t1 + t2
  }

  sub(t1, t2) {
    return t1 - t2
  }
}

// 适配器类
class CalculatorAdapter {
  constructor() {
    this.calculator = new OldCalculator()
  }

  add(t1, t2) {
    return this.calculator.operation(t1, t2, 'add')
  }

  sub(t1, t2) {
    return this.calculator.operation(t1, t2, 'sub')
  }
}

// 使用
const adapter = new CalculatorAdapter()
console.log(adapter.add(10, 5)) // 15
console.log(adapter.sub(10, 5)) // 5
```

## 前端生态中的应用

### Axios 的适配器机制

Axios 既可以在浏览器端使用（基于 XMLHttpRequest/Fetch），也可以在 Node.js 端使用（基于 http 模块）。它通过适配器模式实现了跨环境支持。

```javascript
// 简化的 Axios 适配器逻辑
function getDefaultAdapter() {
  var adapter
  if (typeof XMLHttpRequest !== 'undefined') {
    // 浏览器环境：使用 XHR 适配器
    adapter = require('./adapters/xhr')
  } else if (typeof process !== 'undefined') {
    // Node.js 环境：使用 HTTP 适配器
    adapter = require('./adapters/http')
  }
  return adapter
}
```

### Vue 的计算属性 (Computed)

计算属性在某种意义上也是一种适配器，它将原始数据适配成模板所需要的格式。

```javascript
// 原始数据
const user = {
  firstName: 'John',
  lastName: 'Doe',
  timestamp: 1629876543210,
}

// 适配后供视图使用
const userViewModel = {
  fullName: computed(() => `${user.firstName} ${user.lastName}`),
  formattedDate: computed(() => new Date(user.timestamp).toLocaleDateString()),
}
```

### 接口数据适配

后端接口返回的数据结构往往不能直接用于前端组件，需要进行适配。

```javascript
// 后端返回的数据结构
const backendData = [
  { user_id: 1, user_name: 'Alice', user_role: 1 },
  { user_id: 2, user_name: 'Bob', user_role: 2 },
]

// 前端组件需要的数据结构
// { id: number, label: string, isAdmin: boolean }

function adaptUserList(data) {
  return data.map((item) => ({
    id: item.user_id,
    label: item.user_name,
    isAdmin: item.user_role === 1,
  }))
}

const componentData = adaptUserList(backendData)
```

### 兼容旧浏览器 API

Polyfill 本质上就是一种适配器，它将新浏览器的 API 适配到旧浏览器上。

```javascript
// 简单的 fetch 适配器（如果浏览器不支持 fetch，降级使用 XHR）
if (!window.fetch) {
  window.fetch = function (url) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest()
      xhr.open('GET', url)
      xhr.onload = () =>
        resolve({
          text: () => Promise.resolve(xhr.responseText),
          json: () => Promise.resolve(JSON.parse(xhr.responseText)),
        })
      xhr.onerror = reject
      xhr.send()
    })
  }
}
```

## 适配器模式的优势

- **兼容性**：让不兼容的接口协同工作
- **复用性**：复用旧代码而无需修改
- **解耦**：客户端代码与具体的实现细节解耦

## 适配器模式的缺点

- **增加复杂度**：过多的适配器会让系统变得杂乱
- **理解成本**：代码中充斥着各种转换逻辑，可能难以阅读

## 面试重点

**"适配器模式、代理模式、装饰器模式的区别？"**

| 模式           | 核心意图                     | 接口变化                       | 举例                       |
| :------------- | :--------------------------- | :----------------------------- | :------------------------- |
| **适配器模式** | **兼容**：解决接口不兼容问题 | **改变**原接口，使其符合新规范 | 电源转接头、Axios Adapter  |
| **代理模式**   | **控制**：控制对对象的访问   | **不改变**接口，保持一致       | Proxy、VPN、Nginx          |
| **装饰器模式** | **增强**：动态添加功能       | **不改变**接口，保持一致       | 手机壳、Redux Connect、HOC |

**"外观模式 (Facade) 和适配器模式的区别？"**

- **适配器模式**：一对一，主要解决兼容问题（Wrapper）。
- **外观模式**：多对一，主要解决易用性问题，将复杂的子系统封装成一个简单的接口（如 jQuery 的 `$(selector)` 封装了复杂的 DOM 操作）。
