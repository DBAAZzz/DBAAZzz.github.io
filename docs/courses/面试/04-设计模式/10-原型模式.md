---
title: 原型模式
author: DBAAZzz
date: 2025/11/30 23:50
categories:
  - 面试
tags:
  - 设计模式
  - 原型模式
---

## 原型模式

**原型模式**（Prototype Pattern）是指使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

在 JavaScript 中，原型模式不仅仅是一种设计模式，更是**语言的核心机制**。JavaScript 是基于原型的语言，而不是基于类的语言（虽然 ES6 引入了 `class` 关键字，但其本质仍然是语法糖，底层依然是原型链）。

核心思想：

- **克隆**：通过复制现有的对象来创建新对象，而不是通过实例化类。
- **共享**：通过原型链共享方法和属性，节省内存。

## 基本实现

### 1. Object.create()

这是最纯粹的原型模式实现。

```javascript
const userPrototype = {
  sayHello() {
    console.log(`Hello, my name is ${this.name}`)
  },
}

// 基于 userPrototype 创建新对象
const user1 = Object.create(userPrototype)
user1.name = 'Alice'

const user2 = Object.create(userPrototype)
user2.name = 'Bob'

user1.sayHello() // Hello, my name is Alice
user2.sayHello() // Hello, my name is Bob

console.log(user1.__proto__ === userPrototype) // true
```

### 2. 构造函数与 prototype

在 ES6 之前，我们通常使用构造函数结合 `prototype` 属性来实现。

```javascript
function Dog(name) {
  this.name = name
}

// 方法挂载在原型上，所有实例共享
Dog.prototype.bark = function () {
  console.log(`${this.name} says woof!`)
}

const dog1 = new Dog('Buddy')
const dog2 = new Dog('Max')

console.log(dog1.bark === dog2.bark) // true，同一个函数引用
```

## 前端生态中的应用

### JavaScript 原型链继承

这是面试中最基础也最重要的考点。

```javascript
function Parent(name) {
  this.name = name
}
Parent.prototype.getName = function () {
  return this.name
}

function Child(name, age) {
  Parent.call(this, name) // 1. 构造函数窃取（继承属性）
  this.age = age
}

// 2. 原型链继承（继承方法）
// 使用 Object.create 创建一个空对象，其原型指向 Parent.prototype
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

const child = new Child('Tom', 18)
```

### 高效的对象创建

当初始化一个对象成本很高（例如需要进行复杂的计算、数据库查询或网络请求）时，使用原型模式克隆一个已有的对象会比重新 `new` 一个更高效。

## 面试重点

**"Object.create(null) 和 {} 的区别？"**

- `{}`：创建的对象继承自 `Object.prototype`，拥有 `toString`、`hasOwnProperty` 等内置方法。
- `Object.create(null)`：创建一个**纯净的对象**，没有原型链，不继承任何属性和方法。常用于作为 Map 或字典使用，避免原型链上的属性污染（如 `__proto__` 攻击）。

**"Class 和 Prototype 的关系？"**

ES6 的 `class` 只是原型继承的语法糖。

```javascript
class User {
  constructor(name) {
    this.name = name
  }
  say() {}
}

// 等同于
function User(name) {
  this.name = name
}
User.prototype.say = function () {}
```

**"原型模式的优缺点？"**

- **性能**：创建对象性能好（内存拷贝比执行构造函数快）。
- **内存**：方法共享，减少内存占用。
- **引用类型共享风险**：如果原型上有引用类型属性（如数组），所有实例会共享该属性，修改一个会影响所有（通常在构造函数中定义属性来避免）。
