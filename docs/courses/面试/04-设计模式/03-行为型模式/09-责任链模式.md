---
title: 责任链模式
author: DBAAZzz
date: 2025/11/30 23:30
categories:
  - 面试
tags:
  - 设计模式
  - 责任链模式
---

## 责任链模式

**责任链模式**（Chain of Responsibility Pattern）使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

核心思想：

- **解耦**：请求发送者不需要知道是谁处理的
- **链式处理**：请求在链上传递，每个节点都可以处理、拦截或传递
- **动态组合**：可以动态地增加或修改处理链

责任链模式属于**行为型模式**。

## 基本实现

```javascript
// 处理器基类
class Handler {
  constructor() {
    this.nextHandler = null
  }

  setNext(handler) {
    this.nextHandler = handler
    return handler // 支持链式调用
  }

  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request)
    }
    return null
  }
}

// 具体处理器：处理 500 元以下的报销
class Manager extends Handler {
  handle(amount) {
    if (amount <= 500) {
      console.log(`经理批准了 ${amount} 元的报销`)
    } else {
      console.log(`经理无法处理 ${amount} 元，转交给下一级`)
      super.handle(amount)
    }
  }
}

// 具体处理器：处理 1000 元以下的报销
class Director extends Handler {
  handle(amount) {
    if (amount <= 1000) {
      console.log(`总监批准了 ${amount} 元的报销`)
    } else {
      console.log(`总监无法处理 ${amount} 元，转交给下一级`)
      super.handle(amount)
    }
  }
}

// 具体处理器：处理 1000 元以上的报销
class CEO extends Handler {
  handle(amount) {
    console.log(`CEO 批准了 ${amount} 元的报销`)
  }
}

// 组装责任链
const manager = new Manager()
const director = new Director()
const ceo = new CEO()

manager.setNext(director).setNext(ceo)

// 发起请求
manager.handle(300) // 经理批准
manager.handle(800) // 经理转交 -> 总监批准
manager.handle(5000) // 经理转交 -> 总监转交 -> CEO 批准
```

## 函数式责任链（更常用）

在 JavaScript 中，我们通常使用函数数组来实现责任链，这更加轻量和灵活。

```javascript
class Chain {
  constructor(fn) {
    this.fn = fn
    this.nextChain = null
  }

  setNextSuccessor(nextChain) {
    this.nextChain = nextChain
  }

  passRequest(...args) {
    const result = this.fn.apply(this, args)
    if (result === 'nextSuccessor') {
      return (
        this.nextChain && this.nextChain.passRequest.apply(this.nextChain, args)
      )
    }
    return result
  }
}

// 业务逻辑
const order500 = function (orderType, pay, stock) {
  if (orderType === 1 && pay === true) {
    console.log('500元定金预购，得到100优惠券')
  } else {
    return 'nextSuccessor' // 我不知道下一个节点是谁，反正往后传
  }
}

const order200 = function (orderType, pay, stock) {
  if (orderType === 2 && pay === true) {
    console.log('200元定金预购，得到50优惠券')
  } else {
    return 'nextSuccessor'
  }
}

const orderNormal = function (orderType, pay, stock) {
  if (stock > 0) {
    console.log('普通购买，无优惠券')
  } else {
    console.log('手机库存不足')
  }
}

// 包装成责任链节点
const chainOrder500 = new Chain(order500)
const chainOrder200 = new Chain(order200)
const chainOrderNormal = new Chain(orderNormal)

// 链接
chainOrder500.setNextSuccessor(chainOrder200)
chainOrder200.setNextSuccessor(chainOrderNormal)

// 使用
chainOrder500.passRequest(1, true, 500) // 500元定金...
chainOrder500.passRequest(2, true, 500) // 200元定金...
chainOrder500.passRequest(3, true, 500) // 普通购买...
chainOrder500.passRequest(1, false, 0) // 手机库存不足
```

## 前端生态中的应用

### Axios 拦截器 (Interceptors)

Axios 的拦截器机制是典型的责任链模式。请求拦截器和响应拦截器分别组成两条链。

```javascript
// 伪代码实现
class Axios {
  constructor() {
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager(),
    }
  }

  request(config) {
    // 核心链：[dispatchRequest, undefined]
    const chain = [dispatchRequest, undefined]

    // 请求拦截器：添加到链头
    // chain: [req2, req1, dispatchRequest, undefined]
    this.interceptors.request.forEach((interceptor) => {
      chain.unshift(interceptor.fulfilled, interceptor.rejected)
    })

    // 响应拦截器：添加到链尾
    // chain: [..., dispatchRequest, undefined, res1, res2]
    this.interceptors.response.forEach((interceptor) => {
      chain.push(interceptor.fulfilled, interceptor.rejected)
    })

    let promise = Promise.resolve(config)

    // 依次执行链上的任务
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift())
    }

    return promise
  }
}
```

### Express / Koa 中间件

Node.js 的 Web 框架中间件机制也是责任链模式。

```javascript
// Koa 的洋葱模型
const app = new Koa()

app.use(async (ctx, next) => {
  console.log('Middleware 1 Start')
  await next()
  console.log('Middleware 1 End')
})

app.use(async (ctx, next) => {
  console.log('Middleware 2 Start')
  await next()
  console.log('Middleware 2 End')
})

// 输出：
// Middleware 1 Start
// Middleware 2 Start
// Middleware 2 End
// Middleware 1 End
```

### DOM 事件冒泡

浏览器的事件冒泡机制本身就是一条责任链。事件从目标元素开始，沿着 DOM 树向上传递，直到被处理或到达根节点。

```javascript
child.addEventListener('click', (e) => {
  // 处理事件
  e.stopPropagation() // 停止传递
})
```

## 责任链模式的优势

- **降低耦合**：请求者和处理者解耦
- **灵活性**：可以动态增删处理节点，改变处理顺序
- **单一职责**：每个节点只关注自己的处理逻辑

## 责任链模式的缺点

- **性能问题**：链条过长可能影响性能
- **调试困难**：逻辑分散在多个节点中，排查问题较麻烦
- **不能保证被处理**：请求可能传到链尾都没被处理（需要兜底机制）

## 面试重点

**"Koa 的洋葱模型是怎么实现的？"**

核心是 `compose` 函数（koa-compose），它将中间件数组组合成一个嵌套的 Promise 调用链。

```javascript
function compose(middleware) {
  return function (context, next) {
    let index = -1
    return dispatch(0)

    function dispatch(i) {
      if (i <= index)
        return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        // 递归调用：fn(context, next)
        // next 就是 dispatch(i + 1)
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```

## 构建工具中的责任链：Webpack Loader

**高级面试题：** "为什么 Webpack Loader 的执行顺序是从右向左 (Right-to-Left)？"

配置：`use: ['style-loader', 'css-loader', 'sass-loader']`

执行流程：`sass-loader` -> `css-loader` -> `style-loader`。

这实际上是**函数组合 (Function Composition)** 的体现，源自函数式编程。
在数学中，`f(g(x))` 意味着先执行 `g`，再执行 `f`。

Webpack 将这些 Loader 组合成一个处理链：

```javascript
const process = compose(styleLoader, cssLoader, sassLoader)
process(sourceCode)
```

每一个 Loader 就像责任链中的一个节点，它接收上一个节点的处理结果（Source String），转换后传递给下一个节点。这种设计使得 Loader 极其原子化和可复用。

```

```
