---
title: 迭代器模式
author: DBAAZzz
date: 2025/11/30 23:50
categories:
  - 面试
tags:
  - 设计模式
  - 迭代器模式
---

## 迭代器模式

**迭代器模式**（Iterator Pattern）提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

在现代 JavaScript (ES6+) 中，迭代器模式已经被内置到语言层面，是理解 `for...of`、展开运算符 `...`、生成器 `Generator` 的关键。

核心思想：

- **统一接口**：为不同的数据结构（Array, Set, Map, String, NodeList）提供统一的遍历机制。
- **惰性求值**：不需要一次性取出所有数据，支持无限序列。

## 基本实现

### 1. 迭代器协议 (Iterator Protocol)

一个对象只要实现了 `next()` 方法，并且返回 `{ value, done }` 结构，它就是一个迭代器。

```javascript
function createIterator(items) {
  let i = 0
  return {
    next: function () {
      const done = i >= items.length
      const value = done ? undefined : items[i++]
      return { value, done }
    },
  }
}

const iterator = createIterator([1, 2, 3])
console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.next()) // { value: 3, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```

### 2. 可迭代协议 (Iterable Protocol) 与 Symbol.iterator

一个对象如果实现了 `[Symbol.iterator]` 方法，它就是**可迭代对象**，可以被 `for...of` 消费。

```javascript
const myCollection = {
  items: [10, 20, 30],
  [Symbol.iterator]() {
    let i = 0
    return {
      next: () => {
        return {
          value: this.items[i++],
          done: i > this.items.length,
        }
      },
    }
  },
}

for (const val of myCollection) {
  console.log(val) // 10, 20, 30
}
```

### 3. 生成器 (Generator)

Generator 是实现迭代器最简单的方式。

```javascript
function* idMaker() {
  let index = 0
  while (true) {
    yield index++
  }
}

const gen = idMaker()
console.log(gen.next().value) // 0
console.log(gen.next().value) // 1
// 可以无限生成，用到时才计算
```

## 前端生态中的应用

### 1. 统一遍历 (for...of)

ES6 规定，Array, Map, Set, String, TypedArray, arguments 对象, NodeList 等都实现了 Iterator 接口。这意味着你可以用同样的方式遍历它们：

```javascript
const set = new Set(['a', 'b'])
for (const item of set) {
  // ...
}

const str = 'hello'
for (const char of str) {
  // ...
}
```

### 2. 展开运算符与解构

`...` 运算符和数组解构本质上是在消费迭代器。

```javascript
const set = new Set([1, 2, 3])
const arr = [...set] // [1, 2, 3]
const [first, second] = set // first=1, second=2
```

### 3. 异步迭代器 (Async Iterator)

处理异步数据流（如文件流、网络请求流）。

```javascript
const asyncIterable = {
  [Symbol.asyncIterator]() {
    let i = 0
    return {
      next() {
        if (i < 3) {
          return Promise.resolve({ value: i++, done: false })
        }
        return Promise.resolve({ done: true })
      },
    }
  },
}

;(async () => {
  for await (const num of asyncIterable) {
    console.log(num)
  }
})()
```

### 4. Redux-Saga

Redux-Saga 广泛使用 Generator 函数来管理副作用（异步操作），让异步代码看起来像同步代码，且易于测试。

## 面试重点

**"for...of 和 for...in 的区别？"**

- `for...in`：遍历对象的**可枚举属性键名**（key），包括原型链上的属性。适合普通对象。
- `for...of`：遍历**可迭代对象的值**（value）。适合数组、Set、Map 等。不适用于普通对象（除非实现了 `Symbol.iterator`）。

**"如何让一个普通对象支持 for...of 遍历？"**

需要在对象上部署 `[Symbol.iterator]` 方法。

**"迭代器模式解决了什么问题？"**

解决了不同数据结构遍历方式不一致的问题，提供了一个统一的访问接口。
