---
title: 命令模式
author: DBAAZzz
date: 2025/11/30 23:50
categories:
  - 面试
tags:
  - 设计模式
  - 命令模式
---

## 命令模式

**命令模式**（Command Pattern）将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

核心思想：

- **封装请求**：把“做什么”封装成对象。
- **解耦**：请求的发起者（Invoker）和执行者（Receiver）解耦。
- **撤销/重做**：因为请求是对象，可以保存历史记录。

## 基本实现

模拟一个简单的编辑器命令。

```javascript
// Receiver: 真正的执行者
class Editor {
  constructor() {
    this.content = ''
  }
  append(text) {
    this.content += text
    console.log(`Current content: ${this.content}`)
  }
  delete(length) {
    this.content = this.content.slice(0, -length)
    console.log(`Current content: ${this.content}`)
  }
}

// Command: 命令接口
class AppendCommand {
  constructor(editor, text) {
    this.editor = editor
    this.text = text
  }
  execute() {
    this.editor.append(this.text)
  }
  undo() {
    this.editor.delete(this.text.length)
  }
}

// Invoker: 命令管理者
class CommandManager {
  constructor() {
    this.history = []
    this.redoStack = []
  }

  execute(command) {
    command.execute()
    this.history.push(command)
    this.redoStack = [] // 清空重做栈
  }

  undo() {
    const command = this.history.pop()
    if (command) {
      command.undo()
      this.redoStack.push(command)
    }
  }

  redo() {
    const command = this.redoStack.pop()
    if (command) {
      command.execute()
      this.history.push(command)
    }
  }
}

// 使用
const editor = new Editor()
const manager = new CommandManager()

const cmd1 = new AppendCommand(editor, 'Hello')
const cmd2 = new AppendCommand(editor, ' World')

manager.execute(cmd1) // Hello
manager.execute(cmd2) // Hello World
manager.undo() // Hello
manager.redo() // Hello World
```

## 前端生态中的应用

### 1. 富文本编辑器 / Canvas 绘图应用

这是命令模式最典型的应用场景。所有的操作（加粗、输入、删除、画线、填充）都被封装成 Command 对象，存入栈中，从而实现无限级的 Undo/Redo。

### 2. 异步任务队列

如果需要控制并发请求数量，或者实现重试机制，可以将 HTTP 请求封装成 Command 对象，放入队列中调度执行。

```javascript
class RequestCommand {
  constructor(url) {
    this.url = url
  }
  execute() {
    return fetch(this.url)
  }
}

class Queue {
  constructor() {
    this.commands = []
  }
  add(command) {
    this.commands.push(command)
  }
  async run() {
    for (const cmd of this.commands) {
      await cmd.execute()
    }
  }
}
```

### 3. Redux 的 Action

Redux 中的 `Action` 本质上就是一个数据化的命令对象。

- `dispatch(action)` 相当于 Invoker 发起命令。
- `Reducer` 相当于 Receiver，根据 Action 的类型执行相应的状态修改。
- Redux DevTools 利用这些 Action 记录实现了“时间旅行”（Time Travel）调试，这正是命令模式支持撤销/重做的体现。

## 面试重点

**"如何实现一个支持撤销/重做的画板？"**

这是高级前端常考的系统设计题。
关键点：

1. 不要在画板上直接操作。
2. 将每一步操作（画线、画圆）封装成类，包含 `execute`（画）和 `undo`（擦除或重绘）方法。
3. 维护 `history` 栈。
4. 优化：对于无法逆向操作的（如复杂的滤镜），可以使用“备忘录模式”保存快照，或者保存操作指令序列，Undo 时清空画布并重放指令序列到 N-1 步。
