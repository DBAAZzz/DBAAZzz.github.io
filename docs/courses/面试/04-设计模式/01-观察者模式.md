---
title: 观察者模式
author: DBAAZzz
date: 2025/11/29 00:30
categories:
  - 面试
tags:
  - 设计模式
  - 观察者模式
---

## 观察者模式

观察者模式定义了一种`一对多(One-to-Many)`的依赖关系，让多个观察者对象同时监听某一个主题对象。当这个主题对象的状态发生变化时，它会通知所有依赖于它的观察者对象，使它们能够自动更新自己。

观察者模式的核心角色包括：

- **主题（Subject）**：维护观察者列表，提供添加、删除观察者的方法，并在状态改变时调用通知方法。
- **观察者（Observer）**：提供一个更新接口，用于在接收到通知时执行相应的逻辑。

::: tip 提示
在观察者模式中，观察者是知道 `Subject` 的，`Subject` 也记录了观察者；

而在发布订阅模式中，两者互不相识，中间有一个调度中心（Event Channel）来统一管理事件分发。
:::

```javascript
// 被观察者（Subject）
class Subject {
  constructor() {
    this.observers = [] // 直接维护观察者列表
  }

  // 添加观察者
  addObserver(observer) {
    this.observers.push(observer)
  }

  // 移除观察者
  removeObserver(observer) {
    const index = this.observers.indexOf(observer)
    if (index > -1) {
      this.observers.splice(index, 1)
    }
  }

  // 通知所有观察者
  notify(data) {
    this.observers.forEach((observer) => {
      observer.update(data) // 直接调用观察者的方法
    })
  }
}

// 观察者（Observer）
class Observer {
  constructor(name) {
    this.name = name
  }

  update(data) {
    console.log(`${this.name} 收到更新：${data}`)
  }
}

// 使用示例
const subject = new Subject()

const observer1 = new Observer('观察者1')
const observer2 = new Observer('观察者2')

subject.addObserver(observer1)
subject.addObserver(observer2)

subject.notify('天气变化了')
// 输出：
// 观察者1 收到更新：天气变化了
// 观察者2 收到更新：天气变化了
```

## 观察模式和发布订阅模式的区别

| 特性     | 观察者模式 (`Observer`)                                                 | 发布-订阅模式 (`Publish-Subscribe`)                                           |
| -------- | ----------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| 耦合度   | 松耦合，但有依赖。Subject 必须知道 Observer 的存在（维护了一个 list）。 | 完全解耦。Publisher 和 Subscriber 互不相识，通过第三方（Event Channel）通信。 |
| 通信方式 | 直接通信。Subject 直接调用 Observer 的方法。                            | 间接通信。消息通过调度中心分发。                                              |
| 常见场景 | Vue 的依赖收集 (Dep & Watcher)、DOM 事件监听。                          | 全局 EventBus、Node.js 的 EventEmitter、消息队列。                            |

## 前端生态中的应用

### Vue.js 的响应式系统 (核心应用)

- **Subject**: `Dep` (Dependency)。每个响应式属性（data 中的 key）都有一个对应的 Dep 实例，用来收集依赖。
- **Observer**: `Watcher`。每个组件实例或 computed 属性对应一个 Watcher。

流程:

依赖收集 (Getter): 当组件渲染时，读取数据，触发 Getter，Watcher 把自己添加到该属性的 Dep 中。

派发更新 (Setter): 当数据变化时，触发 Setter，Dep 遍历内部的 Watcher 列表，调用 update() 方法，从而触发组件重新渲染。

### 现代浏览器 API

浏览器为了性能优化，推出了一系列基于观察者模式的 API（通常是异步的）：

- IntersectionObserver: 监听元素是否进入可视区域（懒加载核心）。

- MutationObserver: 监听 DOM 树的变化。

- ResizeObserver: 监听元素尺寸变化。

- PerformanceObserver: 监听性能指标。

## 深度解析：异步调度与 nextTick

**高级面试题：** "为什么 Vue 的响应式更新是异步的？"

如果在观察者模式中，Subject 每次 `notify` 都同步调用 Observer 的 `update`，那么当我们在一个操作中修改了 10 次数据：

```javascript
this.count++
this.count++
// ... 10次
```

Watcher 就会收到 10 次通知，触发 10 次 DOM 更新。这在性能上是不可接受的。

**解决方案：队列 + 异步微任务**

1. **队列 (Queue)**: 当 Watcher 被 notify 时，并不会立即执行，而是把自己推入一个全局队列中（去除重复 ID）。
2. **异步刷库 (Flush)**: 通过 `Promise.resolve().then()` (Microtask) 或 `setTimeout` (Macrotask) 注册一个异步任务。
3. **执行**: 在当前调用栈清空后，浏览器执行微任务，取出队列中的 Watcher，一次性执行 `run()` 更新 DOM。

这就是 Vue `nextTick` 的核心原理，也是观察者模式在高性能场景下的进阶应用。
