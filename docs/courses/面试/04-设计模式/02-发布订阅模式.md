---
title: 发布-订阅模式
author: DBAAZzz
date: 2025/11/29 00:30
categories:
  - 面试
tags:
  - 设计模式
  - 发布-订阅模式
---

## 发布-订阅模式

**发布-订阅模式**是一种消息范式，其中消息的发送者(发布者)不会直接将消息发送给特定的接收者(订阅者)，而是通过一个事件通道(`Event Channel`)或事件总线(`Event Bus`)进行解耦。

三个关键角色：

- `Publisher`(发布者)：触发事件，不关心谁来处理
- `Event Channel`(事件中心)：管理事件和订阅关系的中介
- `Subscriber`(订阅者)：注册感兴趣的事件，等待通知

与观察者模式的关键区别是：发布-订阅模式通过事件中心完全解耦了发布者和订阅者，它们互不知晓对方的存在。

```javascript
class EventEmitter {
  constructor() {
    this.events = new Map()
  }

  // 订阅事件
  on(event, callback) {
    if (!this.events.has(event)) {
      this.events.set(event, [])
    }
    this.events.get(event).push(callback)

    // 返回取消订阅函数
    return () => this.off(event, callback)
  }

  // 一次性订阅
  once(event, callback) {
    const wrapper = (...args) => {
      callback(...args)
      this.off(event, wrapper)
    }
    this.on(event, wrapper)
  }

  // 取消订阅
  off(event, callback) {
    if (!this.events.has(event)) return

    if (callback) {
      const callbacks = this.events.get(event)
      const index = callbacks.indexOf(callback)
      if (index > -1) {
        callbacks.splice(index, 1)
      }
    } else {
      this.events.delete(event)
    }
  }

  // 发布事件
  emit(event, ...args) {
    if (!this.events.has(event)) return

    const callbacks = this.events.get(event).slice() // 拷贝避免在遍历时修改
    callbacks.forEach((callback) => {
      try {
        callback(...args)
      } catch (error) {
        console.error(`Error in event handler for ${event}:`, error)
      }
    })
  }
}
```

## 前端生态中的应用

### Node.js 的 EventEmitter (核心应用)

Node.js 的核心模块 `events` 是该模式最标准的实现。几乎所有 Node 的 I/O 操作（Stream, HTTP Request）都继承自`EventEmitter`。

### webpack 中的 tapable 插件系统

Webpack 的核心库 `Tapable` 是发布-订阅模式的变种。Webpack 的编译流程是一系列钩子（Hooks），Plugins 在这些钩子上注册（订阅），Compiler 在构建过程中触发（发布）这些钩子。这是 Webpack 极其灵活的根本原因。

### Vue 2 EventBus

new Vue() 实例常被用作全局 EventBus，用于兄弟组件通信（$on, $emit）。

### 微前端通信 (Micro-frontends)

在 qiankun 或 single-spa 架构中，主应用与子应用、子应用与子应用之间通常是隔离的。为了通信，常构建一个基于 `CustomEvent` 或全局 `EventEmitter` 的消息总线。

## 面试重点

“既然发布订阅模式解耦这么好，为什么还要用 Vuex/Pinia/Redux？” 或者 “它有什么缺点？”

### 缺点

- 状态分散，难以追踪
- 缺乏时间旅行和调试能力
- 无法保证数据一致性
- 内存泄漏风险极高
- 缺乏类型安全

## 生产环境事故：内存泄漏排查

**高级面试题：** "在 React/Vue 单页应用中，发布订阅模式最容易导致什么问题？"

**答案：内存泄漏 (Memory Leak)。**

在 SPA 中，组件会被频繁创建和销毁。如果在组件挂载 (`mount` / `useEffect`) 时订阅了全局 EventBus，但忘记在组件销毁 (`unmount` / `cleanup`) 时取消订阅：

```javascript
// ❌ 错误示范
useEffect(() => {
  eventBus.on('msg', handleMsg)
  // 忘记返回清理函数
}, [])
```

**后果：**
即便组件被销毁了，`handleMsg` 函数依然被保存在 EventBus 的 `events` 列表中。该函数闭包引用的组件实例、DOM 元素等都无法被垃圾回收 (GC)。随着页面切换次数增加，内存占用会无限上涨，最终导致页面卡顿甚至崩溃。

**最佳实践：**
始终遵循 **"谁订阅，谁取消"** 的原则，利用 WeakMap 或自动清理机制（如 Vue 的 `onUnmounted`）来管理订阅。
