---
title: 代理模式
author: DBAAZzz
date: 2025/11/30 23:30
categories:
  - 面试
tags:
  - 设计模式
  - 代理模式
---

## 代理模式

**代理模式**为其他对象提供一种代理以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介的作用。

核心角色：

- **目标对象（Subject）**：定义了代理和真实对象的共同接口
- **真实对象（RealSubject）**：真正执行业务逻辑的对象
- **代理对象（Proxy）**：持有真实对象的引用，可以在调用真实对象前后添加额外逻辑

代理模式的主要用途：

- **控制访问**：权限验证、延迟加载
- **增强功能**：日志记录、性能监控、缓存
- **解耦**：客户端不直接访问真实对象

## 基本实现

```javascript
// 真实对象
class RealImage {
  constructor(filename) {
    this.filename = filename
    this.loadFromDisk()
  }

  loadFromDisk() {
    console.log(`Loading image: ${this.filename}`)
  }

  display() {
    console.log(`Displaying image: ${this.filename}`)
  }
}

// 代理对象
class ProxyImage {
  constructor(filename) {
    this.filename = filename
    this.realImage = null
  }

  display() {
    if (!this.realImage) {
      this.realImage = new RealImage(this.filename) // 延迟加载
    }
    this.realImage.display()
  }
}

// 使用
const image = new ProxyImage('photo.jpg')
// 此时图片还未加载
image.display() // Loading image: photo.jpg, Displaying image: photo.jpg
image.display() // Displaying image: photo.jpg (不会重复加载)
```

## ES6 Proxy（现代实现）

ES6 原生提供的 `Proxy` 对象，可以拦截对象的各种操作：

```javascript
const target = {
  name: 'Alice',
  age: 25,
}

const handler = {
  get(target, prop) {
    console.log(`读取属性: ${prop}`)
    return target[prop]
  },
  set(target, prop, value) {
    console.log(`设置属性: ${prop} = ${value}`)
    if (prop === 'age' && typeof value !== 'number') {
      throw new TypeError('Age must be a number')
    }
    target[prop] = value
    return true
  },
}

const proxy = new Proxy(target, handler)

console.log(proxy.name) // 读取属性: name, Alice
proxy.age = 26 // 设置属性: age = 26
// proxy.age = 'invalid' // 抛出错误
```

## 常见的代理类型

### 1. 缓存代理

```javascript
function createCacheProxy(fn) {
  const cache = new Map()

  return new Proxy(fn, {
    apply(target, thisArg, args) {
      const key = JSON.stringify(args)
      if (cache.has(key)) {
        console.log('从缓存中获取')
        return cache.get(key)
      }
      const result = target.apply(thisArg, args)
      cache.set(key, result)
      return result
    },
  })
}

// 使用
const fibonacci = createCacheProxy(function (n) {
  console.log(`计算 fibonacci(${n})`)
  if (n <= 1) return n
  return fibonacci(n - 1) + fibonacci(n - 2)
})

console.log(fibonacci(10)) // 会有大量计算
console.log(fibonacci(10)) // 从缓存中获取，直接返回
```

### 2. 防抖/节流代理

```javascript
function createDebounceProxy(fn, delay) {
  let timer = null

  return new Proxy(fn, {
    apply(target, thisArg, args) {
      clearTimeout(timer)
      timer = setTimeout(() => {
        target.apply(thisArg, args)
      }, delay)
    },
  })
}

// 使用
const search = createDebounceProxy((keyword) => {
  console.log(`搜索: ${keyword}`)
}, 300)

search('hello')
search('hello world') // 只会执行这一次
```

### 3. 权限代理

```javascript
function createAuthProxy(obj, role) {
  return new Proxy(obj, {
    get(target, prop) {
      if (prop === 'salary' && role !== 'admin') {
        throw new Error('无权访问薪资信息')
      }
      return target[prop]
    },
  })
}

const employee = { name: 'Bob', salary: 10000 }

const userProxy = createAuthProxy(employee, 'user')
console.log(userProxy.name) // Bob
// console.log(userProxy.salary) // 抛出错误

const adminProxy = createAuthProxy(employee, 'admin')
console.log(adminProxy.salary) // 10000
```

## 前端生态中的应用

### Vue 3 的响应式系统

Vue 3 使用 `Proxy` 实现响应式，相比 Vue 2 的 `Object.defineProperty` 有更好的性能和更强的功能：

```javascript
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key, receiver) {
      track(target, key) // 依赖收集
      return Reflect.get(target, key, receiver)
    },
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver)
      trigger(target, key) // 触发更新
      return result
    },
  })
}
```

### 图片懒加载

```javascript
class LazyImage {
  constructor(selector) {
    this.images = document.querySelectorAll(selector)
    this.observer = new IntersectionObserver(this.loadImage.bind(this))

    this.images.forEach((img) => this.observer.observe(img))
  }

  loadImage(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target
        img.src = img.dataset.src
        this.observer.unobserve(img)
      }
    })
  }
}
```

### HTTP 请求拦截器（Axios Interceptor）

```javascript
axios.interceptors.request.use(
  (config) => {
    // 在请求发送前添加 token
    config.headers.Authorization = `Bearer ${getToken()}`
    return config
  },
  (error) => Promise.reject(error)
)

axios.interceptors.response.use(
  (response) => response.data,
  (error) => {
    if (error.response.status === 401) {
      // 跳转到登录页
      router.push('/login')
    }
    return Promise.reject(error)
  }
)
```

### Service Worker（网络代理）

Service Worker 作为网络请求的代理，可以实现离线缓存、请求拦截等功能。

## 代理模式的优势

- **单一职责**：真实对象只关注业务逻辑，代理处理额外功能
- **开闭原则**：可以在不修改真实对象的情况下扩展功能
- **保护目标对象**：控制访问权限，延迟加载资源

## 代理模式的缺点

- **增加复杂度**：引入了额外的抽象层
- **性能开销**：每次访问都要经过代理

## 面试重点

**"Proxy 和 Object.defineProperty 的区别？"**

| 特性     | Object.defineProperty            | Proxy                |
| -------- | -------------------------------- | -------------------- |
| 监听能力 | 只能监听已存在的属性             | 可以监听整个对象     |
| 数组     | 无法监听数组索引和 length 的变化 | 可以直接监听数组变化 |
| 新增属性 | 需要手动调用 `Vue.set`           | 自动监听             |
| 删除属性 | 需要手动调用 `Vue.delete`        | 自动监听             |
| 性能     | 需要递归遍历所有属性             | 懒代理，性能更好     |
| 兼容性   | 兼容 IE9+                        | 不兼容 IE            |
| 应用     | Vue 2                            | Vue 3                |

**"代理模式和装饰器模式的区别？"**

- **代理模式**：关注**访问控制**，可以不暴露原对象
- **装饰器模式**：关注**功能增强**，透明地扩展对象功能

## 硬核应用：微前端沙箱 (Sandbox)

**高级面试题：** "qiankun 等微前端框架是如何隔离子应用全局变量的？"

答案是 **Proxy 沙箱 (LegacySandbox / ProxySandbox)**。

框架会为每个子应用创建一个 `window` 的代理对象：

```javascript
class ProxySandbox {
  constructor() {
    const rawWindow = window
    const fakeWindow = {}

    this.proxy = new Proxy(fakeWindow, {
      get(target, p) {
        // 优先从 fakeWindow 取，没有则回退到 rawWindow
        return p in target ? target[p] : rawWindow[p]
      },
      set(target, p, value) {
        // 所有的修改都只作用于 fakeWindow，不污染全局 window
        target[p] = value
        return true
      },
    })
  }
}
```

当子应用卸载时，只需要丢弃 `fakeWindow`，全局环境依然是干净的。

## 为什么 Proxy 一定要配合 Reflect？

**高级面试题：** "为什么 Vue 3 的响应式中要用 `Reflect.get(target, key, receiver)` 而不是直接 `target[key]`？"

**关键在于 `this` 的指向。**

假设有一个对象 `obj` 继承自 `proto`，且 `proto` 上有一个 getter 访问了 `this.bar`。
如果我们代理了 `obj`，当我们访问 `proxy.foo` (foo 在原型上) 时，如果直接使用 `target[key]`，getter 中的 `this` 会指向原始对象 `obj`（或者原型对象），而不是代理对象 `proxy`。

这会导致：**getter 内部访问的其他属性不会触发依赖收集！**

`Reflect.get(target, key, receiver)` 的第三个参数 `receiver` 正是用来修正 `this` 指向的，确保 getter 执行时，`this` 依然指向 Proxy，从而保证依赖收集链路的完整性。
