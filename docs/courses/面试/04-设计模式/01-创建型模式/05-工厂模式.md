---
title: 工厂模式
author: DBAAZzz
date: 2025/11/30 23:30
categories:
  - 面试
tags:
  - 设计模式
  - 工厂模式
---

## 工厂模式

**工厂模式**是一种创建型设计模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象。

核心优势：

- **解耦创建逻辑**：将对象的创建和使用分离
- **隐藏复杂性**：客户端不需要知道具体的类名和创建细节
- **集中管理**：统一的地方管理对象的创建

工厂模式主要分为三种：

1. **简单工厂模式**（`Simple Factory`）
2. **工厂方法模式**（`Factory Method`）
3. **抽象工厂模式**（`Abstract Factory`）

## 简单工厂模式

由一个工厂对象决定创建哪一种产品类的实例。

```javascript
// 产品类
class User {
  constructor(name, role) {
    this.name = name
    this.role = role
  }
}

// 简单工厂
class UserFactory {
  static createUser(name, role) {
    switch (role) {
      case 'admin':
        return new User(name, ['user:read', 'user:write', 'user:delete'])
      case 'editor':
        return new User(name, ['user:read', 'user:write'])
      case 'viewer':
        return new User(name, ['user:read'])
      default:
        throw new Error('Invalid role')
    }
  }
}

// 使用
const admin = UserFactory.createUser('Alice', 'admin')
const editor = UserFactory.createUser('Bob', 'editor')
```

::: tip 简单工厂的特点

- 适合产品类较少且相对固定的场景
- 缺点是违反了开闭原则，新增产品需要修改工厂类
  :::

## 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。

```javascript
// 抽象产品
class Button {
  render() {
    throw new Error('子类必须实现 render 方法')
  }
}

// 具体产品
class IOSButton extends Button {
  render() {
    return '<button class="ios-button">iOS Button</button>'
  }
}

class AndroidButton extends Button {
  render() {
    return '<button class="android-button">Android Button</button>'
  }
}

// 抽象工厂
class ButtonFactory {
  createButton() {
    throw new Error('子类必须实现 createButton 方法')
  }
}

// 具体工厂
class IOSButtonFactory extends ButtonFactory {
  createButton() {
    return new IOSButton()
  }
}

class AndroidButtonFactory extends ButtonFactory {
  createButton() {
    return new AndroidButton()
  }
}

// 使用
const iosFactory = new IOSButtonFactory()
const iosButton = iosFactory.createButton()
console.log(iosButton.render())
```

## 前端生态中的应用

### React.createElement

React 的 `createElement` 本质上就是一个工厂函数，根据传入的 `type` 创建不同的 React 元素：

```javascript
React.createElement('div', { className: 'container' }, 'Hello')
// 等价于
<div className="container">Hello</div>
```

### Vue 的 createApp

Vue 3 使用工厂函数 `createApp` 创建应用实例：

```javascript
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)
app.mount('#app')
```

### jQuery 的 $()

jQuery 的核心函数 `$()` 是一个工厂函数，根据参数类型返回不同的对象：

```javascript
$('#id') // 根据 id 选择器创建 jQuery 对象
$('.class') // 根据 class 选择器创建 jQuery 对象
$('<div>') // 创建新的 DOM 元素
$(document) // 将 DOM 对象包装为 jQuery 对象
```

### Axios 的实例工厂

```javascript
import axios from 'axios'

// 创建不同配置的 axios 实例
const apiClient = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 5000,
})

const authClient = axios.create({
  baseURL: 'https://auth.example.com',
  timeout: 3000,
})
```

### HTTP 请求库的适配器

很多请求库会根据环境（浏览器/Node.js）自动选择不同的适配器（XMLHttpRequest / http 模块）：

```javascript
function createHTTPClient() {
  if (typeof window !== 'undefined') {
    // 浏览器环境
    return new XMLHttpRequestAdapter()
  } else {
    // Node.js 环境
    return new NodeHTTPAdapter()
  }
}
```

## 工厂模式的优势

- **解耦**：创建逻辑与使用逻辑分离
- **扩展性**：新增产品只需新增工厂类，符合开闭原则
- **统一管理**：对象创建集中管理，便于维护

## 工厂模式的缺点

- **类的数量增加**：每新增一个产品就需要增加一个工厂类
- **增加复杂度**：对于简单场景可能过度设计

## 面试重点

**"简单工厂、工厂方法、抽象工厂有什么区别？"**

| 模式     | 特点                                     | 适用场景             |
| -------- | ---------------------------------------- | -------------------- |
| 简单工厂 | 一个工厂类负责创建所有产品               | 产品种类少，相对固定 |
| 工厂方法 | 每个产品对应一个工厂类                   | 产品种类多，易扩展   |
| 抽象工厂 | 创建一系列相关或相互依赖的对象（产品族） | 跨平台 UI 组件库等   |

**"工厂模式和策略模式的区别？"**

- **工厂模式**：关注对象的**创建**（怎么生）
- **策略模式**：关注算法的**使用**（怎么用）
