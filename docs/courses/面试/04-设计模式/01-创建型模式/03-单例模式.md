---
title: 单例模式
author: DBAAZzz
date: 2025/11/30 23:00
categories:
  - 面试
tags:
  - 设计模式
  - 单例模式
---

## 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

重点内容：

1. 实现原理： 如何利用闭包（Closure）或 ES6 的静态属性/方法来保持状态。
2. 惰性单例（Lazy Initialization）： 在需要时才创建实例，而非页面加载时立即创建。
3. 透明单例： 使用者无需知道这是一个单例，照常使用 new，但拿到的总是同一个实例。
4. 模块化机制： 理解 ES6 Module (import/export) 本身就是一种天然的单例模式。

```javascript
class Logger {
  log(msg) {
    console.log(msg)
  }
}
const logger = new Logger()
export default logger
```

借助模块系统，模块导出单一实例。优点是简单、惰性加载，缺点是难以在测试中 reset（除非改造）。

```javascript
export class Cache {
  private static instance: Cache | null = null;
  private store = new Map<string, any>();

  private constructor(){}

  static getInstance(){
    if (!Cache.instance) Cache.instance = new Cache();
    return Cache.instance;
  }

  get(key: string){ return this.store.get(key) }
  set(key: string, value: any){ this.store.set(key, value)}
}
```

优点：显式控制实例化，便于在需要时创建；便于实现延迟初始化。
缺点：仍然是全局状态，测试需提供 Cache['instance']=null 或提供 reset()。

```javascript
const Singleton = (function () {
  let instance
  function init() {
    return { value: Math.random() }
  }
  return {
    getInstance: function () {
      if (!instance) instance = init()
      return instance
    },
  }
})()
```

使用闭包+IIFE 实现单例。优点是简单、直观，缺点是无法继承和扩展。

## 前端生态中的应用

- 全局状态管理（`Vuex` / `Redux` / `Pinia`）
  整个应用通常只有一个 `Store` 实例。这保证了状态来源的唯一性（Single Source of Truth），避免多份数据副本导致的状态不同步。
- 全局 UI 组件

## 代理模式和单例模式的区别

|                    | 单例模式             | 代理模式                 |
| ------------------ | -------------------- | ------------------------ |
| **属于什么类别？** | 创建型模式           | 结构型模式               |
| **核心思想**       | 管控实例数量         | 管控对象访问             |
| **引入的抽象**     | 全局唯一实例         | 代理层，屏蔽真实对象     |
| **设计动机**       | 整个系统只需一个服务 | 不改变目标对象但增强行为 |

### 单例模式解决的问题

- 全局状态共享
- 资源唯一性（缓存/配置/日志器/API 客户端）
- 生命周期管理（一次初始化、延迟初始化）

### 代理模式解决的问题

- 延迟加载（虚拟代理）
- 缓存代理
- 访问控制（授权/鉴权）
- 日志、监控、埋点（AOP）
- 网络/权限隔离（跨域代理）
- 防抖节流代理（前端高频）

## 架构思考：单例 vs 依赖注入 (DI)

**高级面试题：** "单例模式在大型架构中有什么坏处？如何改进？"

**坏处：**

1.  **隐式依赖**：模块内部直接 `import store`，导致依赖关系不透明。
2.  **测试噩梦**：单例是全局状态，单元测试 A 修改了状态，可能会影响到单元测试 B（Test Pollution）。必须在每个测试前手动 reset。
3.  **耦合度高**：难以替换实现（例如想在测试环境替换成 MockStore）。

**改进方案：依赖注入 (Dependency Injection)**

像 Angular 或 NestJS 这样的框架，不再让组件自己去获取单例，而是通过**容器 (Container)** 将单例**注入**给组件。

```typescript
// 不再直接 import Singleton
class UserController {
  constructor(private userService: UserService) {} // 容器自动注入单例
}
```

这本质上是**控制反转 (IoC)**。虽然 `UserService` 在运行时依然是单例，但对于 `UserController` 来说，它只是一个构造函数参数，测试时可以轻松传入 `new MockUserService()`。这是从"写代码"到"设计架构"的思维跃升。
