---
title: 装饰器模式
author: DBAAZzz
date: 2025/11/30 23:30
categories:
  - 面试
tags:
  - 设计模式
  - 装饰器模式
---

## 装饰器模式

**装饰器模式**允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

核心思想：

- **动态扩展**：在不修改原对象的情况下，动态地给对象添加新功能
- **透明性**：装饰器和被装饰对象实现相同的接口，对外透明
- **组合优于继承**：使用组合而非继承来扩展功能

装饰器模式属于**结构型模式**，是一种比继承更灵活的替代方案。

## 基本实现

```javascript
// 基础组件
class Coffee {
  cost() {
    return 10
  }

  description() {
    return '普通咖啡'
  }
}

// 装饰器基类
class CoffeeDecorator {
  constructor(coffee) {
    this.coffee = coffee
  }

  cost() {
    return this.coffee.cost()
  }

  description() {
    return this.coffee.description()
  }
}

// 具体装饰器：加奶
class MilkDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 2
  }

  description() {
    return this.coffee.description() + ' + 牛奶'
  }
}

// 具体装饰器：加糖
class SugarDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 1
  }

  description() {
    return this.coffee.description() + ' + 糖'
  }
}

// 具体装饰器：加摩卡
class MochaDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 3
  }

  description() {
    return this.coffee.description() + ' + 摩卡'
  }
}

// 使用示例
let coffee = new Coffee()
console.log(`${coffee.description()}: ¥${coffee.cost()}`) // 普通咖啡: ¥10

coffee = new MilkDecorator(coffee)
console.log(`${coffee.description()}: ¥${coffee.cost()}`) // 普通咖啡 + 牛奶: ¥12

coffee = new SugarDecorator(coffee)
console.log(`${coffee.description()}: ¥${coffee.cost()}`) // 普通咖啡 + 牛奶 + 糖: ¥13

coffee = new MochaDecorator(coffee)
console.log(`${coffee.description()}: ¥${coffee.cost()}`) // 普通咖啡 + 牛奶 + 糖 + 摩卡: ¥16
```

## 函数式装饰器（更符合 JavaScript 风格）

```javascript
// 原始函数
function request(url) {
  console.log(`请求: ${url}`)
  return fetch(url)
}

// 日志装饰器
function withLogging(fn) {
  return function (...args) {
    console.log(`[LOG] 调用函数，参数:`, args)
    const result = fn.apply(this, args)
    console.log(`[LOG] 函数返回:`, result)
    return result
  }
}

// 性能监控装饰器
function withTiming(fn) {
  return function (...args) {
    const start = performance.now()
    const result = fn.apply(this, args)
    const end = performance.now()
    console.log(`[TIMING] 执行耗时: ${end - start}ms`)
    return result
  }
}

// 错误处理装饰器
function withErrorHandling(fn) {
  return function (...args) {
    try {
      return fn.apply(this, args)
    } catch (error) {
      console.error('[ERROR]', error)
      throw error
    }
  }
}

// 组合使用
let decoratedRequest = request
decoratedRequest = withLogging(decoratedRequest)
decoratedRequest = withTiming(decoratedRequest)
decoratedRequest = withErrorHandling(decoratedRequest)

decoratedRequest('/api/users')
```

## ES7 装饰器语法（TypeScript）

```typescript
// 方法装饰器
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value

  descriptor.value = function (...args: any[]) {
    console.log(`调用 ${propertyKey}，参数:`, args)
    const result = originalMethod.apply(this, args)
    console.log(`${propertyKey} 返回:`, result)
    return result
  }

  return descriptor
}

// 类装饰器
function sealed(constructor: Function) {
  Object.seal(constructor)
  Object.seal(constructor.prototype)
}

@sealed
class UserService {
  @log
  getUser(id: number) {
    return { id, name: 'Alice' }
  }

  @log
  updateUser(id: number, data: any) {
    return { id, ...data }
  }
}

const service = new UserService()
service.getUser(1)
```

## React 高阶组件（HOC）

React 中的高阶组件本质上就是装饰器模式的应用：

```javascript
// 基础组件
function UserProfile({ user }) {
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  )
}

// 装饰器：添加加载状态
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading...</div>
    }
    return <Component {...props} />
  }
}

// 装饰器：添加错误处理
function withErrorBoundary(Component) {
  return class WithErrorBoundary extends React.Component {
    state = { hasError: false }

    static getDerivedStateFromError(error) {
      return { hasError: true }
    }

    componentDidCatch(error, errorInfo) {
      console.error('Error:', error, errorInfo)
    }

    render() {
      if (this.state.hasError) {
        return <div>Something went wrong.</div>
      }
      return <Component {...this.props} />
    }
  }
}

// 装饰器：添加认证检查
function withAuth(Component) {
  return function WithAuthComponent(props) {
    const { isAuthenticated } = useAuth()

    if (!isAuthenticated) {
      return <Navigate to='/login' />
    }

    return <Component {...props} />
  }
}

// 组合使用
let EnhancedUserProfile = UserProfile
EnhancedUserProfile = withLoading(EnhancedUserProfile)
EnhancedUserProfile = withErrorBoundary(EnhancedUserProfile)
EnhancedUserProfile = withAuth(EnhancedUserProfile)

// 或使用组合函数
const enhance = compose(withAuth, withErrorBoundary, withLoading)
const EnhancedUserProfile = enhance(UserProfile)
```

## 前端生态中的应用

### Express/Koa 中间件

中间件本质上就是装饰器模式，每个中间件为请求处理流程添加新功能：

```javascript
// Express 中间件
app.use(logger) // 日志装饰器
app.use(cors()) // CORS 装饰器
app.use(express.json()) // JSON 解析装饰器
app.use(authenticate) // 认证装饰器

app.get('/api/users', (req, res) => {
  res.json({ users: [] })
})
```

### Vue 混入（Mixins）

Vue 的混入机制也是装饰器模式的一种应用：

```javascript
const LoggerMixin = {
  created() {
    console.log(`组件 ${this.$options.name} 已创建`)
  },
  beforeDestroy() {
    console.log(`组件 ${this.$options.name} 即将销毁`)
  },
}

export default {
  name: 'UserList',
  mixins: [LoggerMixin],
  // ...
}
```

### 防抖/节流函数装饰器

```javascript
function debounce(fn, delay) {
  let timer = null
  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

function throttle(fn, delay) {
  let lastTime = 0
  return function (...args) {
    const now = Date.now()
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 使用
const handleScroll = debounce(() => {
  console.log('处理滚动事件')
}, 300)

window.addEventListener('scroll', handleScroll)
```

## 装饰器模式的优势

- **开闭原则**：无需修改原对象即可扩展功能
- **单一职责**：每个装饰器只负责一个功能
- **灵活组合**：可以动态地添加、移除、组合装饰器
- **比继承更灵活**：避免类爆炸，支持运行时动态组合

## 装饰器模式的缺点

- **增加复杂度**：多层装饰器嵌套会使代码难以理解
- **调试困难**：多层包装导致调试时难以追踪调用栈
- **顺序依赖**：装饰器的顺序可能影响最终结果

## 面试重点

**"装饰器模式和代理模式有什么区别？"**

| 特性     | 装饰器模式                 | 代理模式                     |
| -------- | -------------------------- | ---------------------------- |
| 目的     | 增强功能，添加新行为       | 控制访问                     |
| 关注点   | 功能扩展                   | 访问控制、延迟加载、权限验证 |
| 透明性   | 对外透明，客户端知道被装饰 | 可以透明也可以不透明         |
| 使用场景 | HOC、中间件、函数装饰器    | Proxy、图片懒加载、请求拦截  |
| 数量     | 可以有多个装饰器层层嵌套   | 通常只有一层代理             |
| 关系     | 强调"is-a"关系（同一接口） | 强调"has-a"关系（持有引用）  |

**"为什么 React 推荐使用 Hooks 而非 HOC？"**

- HOC 会导致组件层级嵌套过深（包装地狱）
- Props 命名冲突问题
- 调试困难
- Hooks 提供了更简洁、更直观的逻辑复用方式
