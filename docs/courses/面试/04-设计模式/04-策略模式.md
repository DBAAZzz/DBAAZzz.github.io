---
title: 策略模式
author: DBAAZzz
date: 2025/11/30 23:30
categories:
  - 面试
tags:
  - 设计模式
  - 策略模式
---

## 策略模式

**策略模式**定义了一系列的算法，并将每一个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户。

核心思想：

- **策略（Strategy）**：定义统一的接口或抽象类，封装不同的算法实现
- **上下文（Context）**：持有策略的引用，可以动态切换策略
- **客户端（Client）**：选择并配置具体的策略

这是一种典型的**行为型模式**，用于消除大量的 `if-else` 或 `switch-case` 条件判断。

```javascript
// 定义策略接口
class Strategy {
  calculate(salary) {
    throw new Error('子类必须实现 calculate 方法')
  }
}

// 具体策略 A：绩效为 S
class StrategyS extends Strategy {
  calculate(salary) {
    return salary * 4
  }
}

// 具体策略 B：绩效为 A
class StrategyA extends Strategy {
  calculate(salary) {
    return salary * 3
  }
}

// 具体策略 C：绩效为 B
class StrategyB extends Strategy {
  calculate(salary) {
    return salary * 2
  }
}

// 上下文类
class Bonus {
  constructor(strategy) {
    this.strategy = strategy
  }

  setStrategy(strategy) {
    this.strategy = strategy
  }

  getBonus(salary) {
    return this.strategy.calculate(salary)
  }
}

// 使用示例
const bonus = new Bonus(new StrategyS())
console.log(bonus.getBonus(10000)) // 40000

bonus.setStrategy(new StrategyA())
console.log(bonus.getBonus(10000)) // 30000
```

## 更简洁的实现（推荐）

在 JavaScript 中，由于函数是一等公民，我们可以更简洁地实现策略模式：

```javascript
// 策略对象
const strategies = {
  S: (salary) => salary * 4,
  A: (salary) => salary * 3,
  B: (salary) => salary * 2,
}

// 上下文函数
function calculateBonus(level, salary) {
  return strategies[level](salary)
}

// 使用
console.log(calculateBonus('S', 10000)) // 40000
console.log(calculateBonus('A', 10000)) // 30000
```

## 前端生态中的应用

### 表单验证

多种验证规则（必填、邮箱格式、手机号格式等）就是不同的策略：

```javascript
const validators = {
  required: (value) => value.trim() !== '',
  email: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
  minLength: (min) => (value) => value.length >= min,
  phone: (value) => /^1[3-9]\d{9}$/.test(value),
}

function validate(rules, formData) {
  const errors = {}
  for (const [field, ruleList] of Object.entries(rules)) {
    for (const rule of ruleList) {
      if (!validators[rule.type](formData[field])) {
        errors[field] = rule.message
        break
      }
    }
  }
  return errors
}
```

### React Context + Hooks 的主题切换

```javascript
const themes = {
  light: { background: '#fff', color: '#000' },
  dark: { background: '#000', color: '#fff' },
  blue: { background: '#1e3a8a', color: '#fff' },
}

function ThemeProvider({ children, theme = 'light' }) {
  return (
    <ThemeContext.Provider value={themes[theme]}>
      {children}
    </ThemeContext.Provider>
  )
}
```

### Webpack Loader 和 Plugin

Webpack 在构建时根据文件类型（`.js`, `.css`, `.png`）调用不同的 Loader，这是策略模式的典型应用。

## 策略模式的优势

- **消除条件判断**：没有冗长的 `if-else` 或 `switch-case`
- **开闭原则**：增加新策略无需修改原有代码
- **复用性强**：每个策略都是独立的，可以在不同场景复用
- **易于测试**：每个策略可以单独测试

## 策略模式的缺点

- **策略类数量增多**：每个策略都是一个类或对象
- **客户端需要了解所有策略**：必须知道有哪些策略可选

## 面试重点

**"策略模式和工厂模式有什么区别？"**

|          | 策略模式                           | 工厂模式                         |
| -------- | ---------------------------------- | -------------------------------- |
| 模式分类 | 行为型模式                         | 创建型模式                       |
| 核心目的 | 运行时动态切换算法                 | 创建对象，隐藏创建逻辑           |
| 关注点   | 如何执行（算法的封装和替换）       | 如何创建（对象的实例化过程）     |
| 使用场景 | 多种算法可选，客户端可以灵活配置   | 根据条件创建不同类型的对象       |
| 举例     | 表单验证、支付方式选择、排序算法等 | 根据用户类型创建不同的用户对象等 |
