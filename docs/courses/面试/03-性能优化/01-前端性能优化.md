---
title: 前端性能
author: DBAAZzz
date: 2025/11/20 15:40
categories:
  - 面试
tags:
  - 前端性能
---

## 渲染优化

核心目标： 减少白屏时间，保持页面流畅（FPS 60），减少浏览器渲染管线的负担。

### 回流 (Reflow) vs 重绘 (Repaint)

- 回流 (Reflow/Layout)： 元素的几何属性（宽、高、位置）发生变化，浏览器需要重新计算布局。开销巨大。
- 重绘 (Repaint)： 元素外观（颜色、背景）变化，不影响布局。开销较小。

**回流必将引起重绘，而重绘不一定引起回流。**

| 特性       | 回流 (Reflow)                                     | 重绘 (Repaint)                                       |
| ---------- | ------------------------------------------------- | ---------------------------------------------------- |
| 触发条件   | 宽高、位置、Display (显隐)、字体大小、窗口 resize | 颜色 (color)、背景 (background)、可见性 (visibility) |
| 性能开销   | 极大 (可能波及全局)                               | 较小 (通常只影响局部)                                |
| 渲染流水线 | DOM Tree → Render Tree → **Layout** → Paint       | DOM Tree → Render Tree → **Paint**                   |

#### 优化策略

- 读写分离：避免强制同步布局，不要你在读写 DOM 属性时交替进行。

  ::: tip 提示
  浏览器通常会有一个渲染队列，它会把多次 DOM 修改攒在一起，一次性执行（批量优化）。但是，如果你在修改样式后，立刻读取几何属性，浏览器为了给你返回正确的值，会被迫打断队列，立即执行回流
  :::

- 使用 CSS `Transform` 和 `Opacity`：它们可以跳过回流和重绘，直接在合成线程（Compositor Thread）处理，通常由 GPU 加速。

  ::: tip 提示
  举例说明：

  - 改变 `left` / `top`: 触发 Reflow + Repaint。
    流程: JS -> Style -> Layout -> Paint -> Composite
  - 改变 `transform`: `translate`: 既不触发 Reflow 也不触发 Repaint（在主线程），它直接交给 GPU 处理合成。
    优化流程: JS -> Style -> Composite
    :::

- DOM 操作优化：避免频繁操作 DOM
  ::: tip 提示
  - 使用 DocumentFragment 批量插入 DOM。
  - `display: none`：元素从 Render Tree 中被移除。触发回流 (Reflow)。
  - `visibility: hidden`: 元素还在 Render Tree 中，只是看不见（占据空间）。只触发重绘 (Repaint)。
    :::

### 关键渲染路径 (Critical Rendering Path)

### 虚拟列表

#### 什么是关键渲染路径？

浏览器将代码渲染为像素的步骤：

1. HTML → DOM (文档对象模型)
2. CSS → CSSOM (CSS 对象模型)
3. DOM + CSSOM → Render Tree (渲染树)
4. Layout (布局)
5. Paint (绘制)

#### 核心优化策略

- 优化 CSS（消除渲染阻塞）：CSS 是渲染阻塞资源 (Render Blocking)。构建 Render Tree 必须等待 CSSOM 构建完成。如果没有 CSS，浏览器通常会白屏。
  - 内联关键 CSS。将首屏可见区域的 CSS 直接写在 HTML 的 `<style>` 标签中
  - 推迟非关键 CSS。对于首屏用不到的样式，使用 `rel="preload"` 或在底部加载。
- 优化 JavaScript（消除解析阻塞）：JS 是解析阻塞资源 (Parser Blocking)，浏览器解析 HTML 遇到 `<script>` 时，会暂停解析 DOM，去下载并执行 JS。
  - 使用 defer 和 async
  - 脚本后置：将`<script>`放在`<body>`之前（旧方案，现在更推荐 defer）
- 利用资源提示 (Resource Hints)

#### CSSOM 构建会阻塞 JS 执行

如果存在尚未完整构建的 CSSOM（即正在加载或解析的 CSS），浏览器会强制等待 CSSOM 构建完成后，再执行 JavaScript。

原因：JavaScript 有可能会去读取或修改元素的样式。

为了避免竞态条件和不一致的渲染结果，浏览器采取了最保守的策略：**只要后面有 JS 要执行，并且前面有 CSS 还在处理，那就等 CSS 处理完。**

---

## CPU 优化

核心目标： 避免主线程（Main Thread）阻塞，保证交互响应速度。

### 避免长任务

浏览器的 GUI 渲染线程 和 JS 引擎线程 是互斥的。简单说，JS 跑久了，页面就卡死不动了。

优化目标：避免 `Long Tasks` (长任务)。

#### 优化策略

- `Web Workers`：将图像处理、大文件加密、复杂数学计算等耗时操作移到 `Worker` 线程，不阻塞主线程 UI。
- 时间切片 (`Time Slicing`)
  - (React Fiber 的核心理念) 将一个大任务拆分成多个小任务，在浏览器空闲时执行（利用 `requestIdleCallback` 或 `scheduler`）。

### 事件处理与算法

- 防抖 (Debounce) 与 节流 (Throttle)：
  - 场景：滚动监听、窗口缩放、搜索框输入。
  - 作用：限制高频事件触发 JS 的频率，减少 CPU 消耗。
- 算法复杂度： 避免在循环中进行 `O(n^2)` 的查找，改用 Map/Object 进行 `O(1)` 查找。

---

## 内存优化

核心目标： 防止内存泄漏 (Memory Leaks)，降低内存峰值，避免页面崩溃。

### 内存泄漏场景

- 未清理的全局变量： 意外创建的全局变量无法被回收。
- 被遗忘的定时器/监听器： 组件销毁（Unmount）时，没有清除 `setInterval` 或 `window.addEventListener`。
- 闭包 (Closures)： 不当使用闭包导致外部作用域变量无法释放。
- 分离的 DOM 节点 (Detached DOM)： JS 变量引用了已经从 DOM 树中移除的节点，导致整个节点树无法回收。

### 数据存储优化

- 弱引用 (WeakMap / WeakSet)：
  - 如果键（Key）是对象，当该对象在其他地方没有引用时，WeakMap 不会阻止垃圾回收（GC）。
  - 场景： 存储 DOM 节点的元数据，防止 DOM 移除后内存泄漏。
- 及时置空： 大对象使用完后，手动赋值 `null`（如 `largeData = null`），帮助 GC 识别。
