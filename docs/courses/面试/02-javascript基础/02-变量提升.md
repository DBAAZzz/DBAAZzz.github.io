---
title: 变量提升
author: DBAAZzz
date: 2025/11/28 15:00
categories:
  - 面试
tags:
  - 变量提升
---

## 变量提升

变量提升（Hoisting）是 JavaScript 在 **`编译阶段`**将**变量**和**函数声明**提升到作用域顶部的机制。

注意是声明提升，赋值不提升。

```javascript
console.log(a); // undefined（不是报错）
var a = 1;****

// 实际执行顺序相当于：
var a;
console.log(a);
a = 1;
```

## 不同声明方式的提升行为

- `var` 声明

  - 会提升声明，并初始化为`undefined`
  - 可以在声明前访问（值为 `undefined`）

- `let`、`const` 声明

  - 会提升声明，但不初始化
  - 存在暂时性死区（TDZ）：从作用域开始到声明处
  - 在 TDZ 内访问会报错 ReferenceError

    ```javascript
    console.log(b); // ReferenceError
    let b = 2;
    ```

- function 声明

  - 整个函数定义都会提升
  - 可以在声明前调用

    ```javascript
    foo(); // "hello"

    function foo() {
      console.log("hello");
    }
    ```

- function 表达式

  - 按变量提升规则处理

  ```javascript
  // bar 为 undefined
  bar(); // TypeError: bar is not a function
  var bar = function () {
    console.log("world");
  };
  ```

## 提升优先级

优先级顺序：函数声明 > 形参 > 变量声明

```javascript
console.log(foo);
var foo = 1;
function foo() {}
console.log(foo);

// 等同于

function foo() {}
// var foo 声明被忽略（因为foo已存在）
console.log(foo); // [Function: foo]
foo = 1;
console.log(foo); // 1
```

## 面试重点

### `let`/`const` 的 `TDZ` 真正含义

```javascript
let x = 1;
{
  console.log(x); // ReferenceError（不是1）
  let x = 2;
}
```

`TDZ` 不是"不提升"，而是提升了但处于"未初始化"状态，屏蔽了外层作用域

### 经典陷阱：循环中的变量提升

```javascript
// 陷阱 1：var 在循环中的提升
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 3, 3, 3（不是 0, 1, 2）
  }, 100);
}

// 原因：var 是函数作用域，循环结束后 i = 3
// 所有 setTimeout 回调共享同一个 i

// 解决方案 1：使用 let（块级作用域）
for (let j = 0; j < 3; j++) {
  setTimeout(() => {
    console.log(j); // 0, 1, 2
  }, 100);
}

// 解决方案 2：使用闭包（ES5 时代）
for (var k = 0; k < 3; k++) {
  (function (index) {
    setTimeout(() => {
      console.log(index); // 0, 1, 2
    }, 100);
  })(k);
}
```

### 函数提升 vs 函数表达式

```javascript
// 场景：条件语句中的函数声明（不推荐）
if (true) {
  function sayHi() {
    console.log("Hi from if");
  }
}

// 不同浏览器行为不一致！
// 现代浏览器：函数声明会提升到块级作用域
// 旧版浏览器：可能提升到函数作用域

// 推荐做法：使用函数表达式
if (true) {
  const sayHello = function () {
    console.log("Hello from if");
  };
}
```

## 底层原理：执行上下文

变量提升的本质源于 JavaScript 引擎的**执行上下文 (Execution Context)** 创建过程：

### 执行上下文的生命周期

1. **创建阶段 (Creation Phase)**：

   - 创建**变量对象 (Variable Object, VO)**
   - **扫描函数声明**：在 VO 中创建属性，指向函数体（如果属性已存在，直接覆盖）
   - **扫描变量声明 (`var`)**：在 VO 中创建属性，初始化为 `undefined`（如果属性已存在，**不做任何操作**）
   - **扫描 `let`/`const`**：在 VO 中创建属性，但**不初始化**（处于 TDZ）

2. **执行阶段 (Execution Phase)**：
   - 变量赋值
   - 函数引用
   - 执行代码

### 可视化示例

```javascript
function example() {
  console.log(a); // undefined
  console.log(b); // ReferenceError

  var a = 1;
  let b = 2;

  function inner() {
    return "inner";
  }
}

// --- 创建阶段的变量对象 (VO) ---
// VO = {
//   a: undefined,        // var 声明，初始化为 undefined
//   b: <uninitialized>,  // let 声明，未初始化（TDZ）
//   inner: <function>    // 函数声明，指向函数体
// }
```

## 现代前端中的应用

### React Hooks 中的"闭包陷阱"

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      // 陷阱：这里的 count 永远是初始值 0
      console.log(count);
    }, 1000);

    return () => clearInterval(timer);
  }, []); // 空依赖数组

  // 解决方案：使用函数式更新
  useEffect(() => {
    const timer = setInterval(() => {
      setCount((prev) => {
        console.log(prev); // 正确的最新值
        return prev;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, []);
}
```

### Vue 3 中的响应式陷阱

```javascript
import { ref, watchEffect } from "vue";

const count = ref(0);

// 陷阱：在 setup 顶层直接访问 .value
console.log(count.value); // 0（正确）

function increment() {
  // 这里需要 .value
  count.value++;
}

// 在模板中不需要 .value
// <template>{{ count }}</template>
```

## 最佳实践

### 1. 永远不要使用 `var`

```javascript
// ❌ 不推荐
var name = "DBAA";

// ✅ 推荐
const name = "DBAA"; // 不会改变的值
let age = 25; // 会改变的值
```

### 2. 函数声明的选择

```javascript
// 场景 1：需要提升（自顶向下的代码组织）
main();

function main() {
  helper();
}

function helper() {
  // ...
}

// 场景 2：不需要提升（严格的依赖顺序）
const handler = () => {
  // ...
};

document.addEventListener("click", handler);
```

### 3. 避免在块级作用域中声明函数

```javascript
// ❌ 不推荐（行为不一致）
if (condition) {
  function doSomething() {}
}

// ✅ 推荐
if (condition) {
  const doSomething = () => {};
}
```

## 高频面试题汇总

### 题目 1：输出结果

```javascript
var a = 1;
function test() {
  console.log(a);
  var a = 2;
  console.log(a);
}
test();

// 答案：undefined, 2
// 解析：函数内的 var a 提升到函数顶部，屏蔽了外层的 a
```

### 题目 2：函数与变量同名

```javascript
console.log(typeof foo);
var foo = "variable";
function foo() {}

// 答案："function"
// 解析：函数声明优先级高于变量声明
```

### 题目 3：TDZ 边界

```javascript
function test() {
  // TDZ 开始
  console.log(x); // ReferenceError

  let x = 1;
  // TDZ 结束

  console.log(x); // 1
}
```

### 题目 4：复杂提升场景

```javascript
function complex() {
  console.log(a, b, c);

  var a = 1;
  let b = 2;
  const c = 3;
}

complex();

// 答案：undefined, ReferenceError
// 解析：
// - a 提升并初始化为 undefined
// - b 提升但未初始化（TDZ）
// - 访问 b 时报错，c 不会被执行
```

## 总结

变量提升是 JavaScript 的核心机制之一，理解它需要掌握：

1. **声明提升，赋值不提升**
2. **函数声明 > 形参 > 变量声明**
3. **`let`/`const` 的 TDZ 机制**
4. **执行上下文的创建阶段**
5. **现代开发中避免使用 `var`**
