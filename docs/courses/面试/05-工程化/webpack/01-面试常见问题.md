---
title: 面试常见问题
author: DBAAZzz
date: 2025/12/16 23:00
categories:
  - 面试
tags:
  - webpack
---

## 1. Webpack 的构建流程（核心原理）是怎样的？

这是最经典的 Webpack 面试题，建议分为**三个主要阶段**来回答，并提及**Tapable**事件流。

### 简要流程：

1.  **初始化 (Initialization)**：
    - 读取并合并配置参数（CLI + 配置文件）。
    - 实例化 `Compiler` 对象，注册所有的 Plugin。
    - Plugin 在特定钩子（Hooks）上注册事件。
2.  **编译 (Compilation)**：
    - 从 `entry` 出发，开始解析文件。
    - **Module 解析**：调用匹配的 **Loader** 对文件进行转换（如 TypeScript -> JavaScript）。
    - **依赖分析**：解析转换后的文件，找出依赖模块（`import`/`require`），递归进行编译。
    - 此时建立起 Module Graph（依赖图）。
3.  **生成 (Output)**：
    - **组装 Chunk**：将编译好的 Module 组合成 **Chunk**（代码块）。
    - **生成 Asset**：将 Chunk 转换成最终的文件资源（Assets）。
    - **输出文件**：根据 `output` 配置，将文件写入文件系统。

### 关键点：

整个过程是一个事件驱动的流，基于 **Tapable** 库。Compiler 和 Compilation 对象在不同阶段触发各种钩子（Hooks），Plugin 通过监听这些钩子来介入构建过程。

---

## 2. Loader 和 Plugin 的区别？

| 维度         | Loader (加载器)                                                                           | Plugin (插件)                                                                                                 |
| :----------- | :---------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------ |
| **概念**     | **文件转换器**。                                                                          | **功能扩展器**。                                                                                              |
| **作用**     | 将非 JS 文件（css, png, ts）转换为 Webpack 能识别的 JS 模块。它专注于**单个文件**的转换。 | 作用于 Webpack **整个生命周期**。可以监听构建过程的各个钩子，执行更复杂的任务（打包优化、压缩、注入变量等）。 |
| **运行时机** | 在**编译阶段**，读取文件内容后执行。                                                      | 在**整个构建周期**的特定时间点触发。                                                                          |
| **配置方式** | `module.rules` 中配置。                                                                   | `plugins` 数组中 `new Plugin()`。                                                                             |
| **举例**     | `babel-loader`, `css-loader`, `file-loader`                                               | `HtmlWebpackPlugin`, `CleanWebpackPlugin`, `MiniCssExtractPlugin`                                             |

---

## 3. 列举常用的 Loader 和 Plugin

### 常用的 Loader

- **样式**：`style-loader` (插入 style 标签), `css-loader` (解析 import/url), `postcss-loader` (兼容性处理), `sass-loader` / `less-loader`。
- **文件**：`raw-loader` (读字符串), `file-loader` (输出文件), `url-loader` (小图转 base64)。_(注：Webpack 5 已被 Asset Modules 替代)_
- **编译**：`babel-loader` (ES6+ -> ES5), `ts-loader`。
- **校验**：`eslint-loader`。

### 常用的 Plugin

- `HtmlWebpackPlugin`：自动生成 HTML 文件并注入 script/link。
- `CleanWebpackPlugin`：打包前清理 dist 目录。
- `MiniCssExtractPlugin`：提取 CSS 为独立文件。
- `DefinePlugin`：定义全局环境变量。
- `CopyWebpackPlugin`：复制静态文件。
- `TerserPlugin`：压缩 JS（Webpack 5 内置）。
- `BundleAnalyzerPlugin`：分析打包体积。

---

## 4. Webpack 热更新 (HMR) 原理？

HMR (Hot Module Replacement) 允许在不刷新页面的情况下替换、添加或删除模块。

### 核心步骤：

1.  **启动阶段**：Webpack Dev Server (WDS) 启动，并与浏览器建立 **WebSocket** 连接。
2.  **监听变化**：Webpack 监听到文件变化，重新编译发生变化的模块（增量构建），生成 `manifest` (描述变化) 和 `update chunk` (代码补丁)。
3.  **推送消息**：WDS 通过 WebSocket 向浏览器发送 `hash` 和 `ok` 消息，通知有更新。
4.  **客户端请求**：浏览器端运行时（HMR Runtime）收到通知，通过 AJAX/JSONP 请求最新的更新补丁（`.hot-update.json` 和 `.hot-update.js`）。
5.  **模块替换**：
    - HMR Runtime 拿到新代码。
    - 向上冒泡寻找 `module.hot.accept` 接收过更新的模块。
    - 找到后，执行回调，替换旧模块，执行新代码（如 Vue/React 组件重新渲染）。
    - 如果没找到接收者，强制刷新页面（Live Reload）。

---

## 5. Webpack 性能优化：如何提高构建速度？

### 1. 缩小构建范围

- **`include` / `exclude`**：在 Loader 配置中精确指定 `include` (如 `src`)，排除 `node_modules`。
- **`resolve.extensions`**：减少后缀列表，尽可能精确。

### 2. 利用缓存 (Caching)

- **`cache-loader`**：缓存 Loader 的处理结果（Webpack 5 内置提供了 `cache: { type: 'filesystem' }`，效果更好）。
- **`babel-loader`**：配置 `cacheDirectory: true`。

### 3. 多进程处理 (Parallelism)

- **`thread-loader`**：将耗时的 Loader (如 babel-loader) 放在子进程中运行。
- **`TerserPlugin`**：默认开启 `parallel: true` 多进程压缩。

### 4. 提前构建 / 避免重复

- **DLL (Dynamic Link Library)**：将 React、Vue 等不常变的库提前打包好，开发时直接引用。（注：Webpack 5 推荐使用 **HardSourceWebpackPlugin** 或内置的 **Persistent Caching**，DLL 已逐渐淘汰）。

---

## 6. Webpack 性能优化：如何优化产物体积？

1.  **Code Splitting (代码分割)**：
    - 使用 `SplitChunksPlugin` (配置 `optimization.splitChunks`) 提取公共代码和第三方库。
    - 使用 `import()` 动态导入，实现路由懒加载。
2.  **Tree Shaking**：移除未使用的代码（需使用 ESM）。
3.  **Scope Hoisting**：将多个模块合并到一个函数作用域中，减少闭包开销（生产模式默认开启）。
4.  **压缩代码**：
    - JS: `TerserPlugin`。
    - CSS: `CssMinimizerPlugin`。
5.  **资源处理**：
    - 图片压缩 (`image-webpack-loader`)。
    - 小图转 Base64。
6.  **CDN 加速**：配置 `externals`，将大库（如 React/Vue）通过 CDN 引入，不打入 bundle。

---

## 7. Tree Shaking 的原理是什么？

Tree Shaking 旨在移除 JavaScript 上下文中的未引用代码 (Dead Code)。

### 必要条件：

- 必须使用 **ES6 Modules** (ESM)，因为 ESM 是静态的（import/export 必须在顶层），可以在编译阶段分析依赖关系。CommonJS 是动态的，无法 Tree Shaking。
- 开启 `production` 模式。

### 工作流程：

1.  **标记 (Marking)**：Webpack 编译时分析 ESM 依赖图，标记出所有被导出的模块中，哪些实际上被使用了。
2.  **摇树 (Shaking)**：未被标记使用的导出，不会被添加到最终的 bundle 中。
3.  **压缩 (Minification)**：最后由压缩工具（如 Terser）删除掉这些声明但未使用的变量。

### `sideEffects`：

`package.json` 中的 `sideEffects` 字段非常重要。它告诉 Webpack 哪些文件有“副作用”（即直接执行代码会有全局影响，如修改 prototype 或全局 CSS）。

- `sideEffects: false`：表示所有代码都没有副作用，Webpack 可以安全地删除未使用的 export。
- 如果不配置，Webpack 即使看到未引用，也不敢随便删（怕有副作用）。

---

## 8. Source Map 是什么？生产环境怎么配？

Source Map 建立了构建后的代码与源代码之间的映射关系，用于调试。

### 常见模式关键字：

- **eval**：使用 `eval` 包裹模块，速度快，但无法还原行号。
- **source-map**：生成独立的 `.map` 文件，最完整。
- **cheap**：只包含行信息，没有列信息（速度较快）。
- **module**：包含 Loader 的 source map（能看到源码而非 Babel 转换后的代码）。
- **inline**：将 map 作为 DataURI 嵌入 JS 文件（体积巨大）。

### 最佳实践：

- **开发环境 (Development)**：
  - `eval-cheap-module-source-map`
  - 理由：构建速度快，能看到源码，行号准确。
- **生产环境 (Production)**：
  - `hidden-source-map` (生成 map 但不关联，用于报错监控平台解析)。
  - 或者 `none` (不生成，保护源码)。

---

## 9. Webpack 5 有哪些新特性？

1.  **持久化缓存 (Persistent Caching)**：
    - 以前需要用 `cache-loader` / `hard-source-webpack-plugin`。
    - 现在通过 `cache: { type: 'filesystem' }` 内置支持文件系统缓存，大幅提升二次构建速度。
2.  **Module Federation (模块联邦)**：
    - 允许多个 Webpack 构建之间共享模块（运行时动态加载）。是微前端的重要解决方案。
3.  **Asset Modules (资源模块)**：
    - 原生支持图片/字体等资源，不再需要 `file-loader` / `url-loader`。
    - 配置 `type: 'asset/resource'` 等。
4.  **更强的 Tree Shaking**：
    - 支持嵌套模块的 Tree Shaking。
    - 支持 CommonJS 的 Tree Shaking（通过静态分析分析 `exports`）。
5.  **移除 Node.js Polyfill**：
    - Webpack 5 不再自动为 Node.js 核心模块（如 crypto, path）注入 polyfill，需要手动安装配置。

---

## 10. 文件指纹 (Hash) 的区别？

Webpack 输出文件名通常带 Hash，用于浏览器缓存控制。

1.  **`hash`**：
    - 和整个项目的构建相关。只要项目里有任何一个文件改动，整个项目构建的 Hash 都会变。
    - **缺点**：改了一个 JS，CSS 的 Hash 也会变，缓存失效。
2.  **`chunkhash`**：
    - 根据入口 (Entry) 进行依赖分析。同一个 Chunk 下的模块共用一个 Hash。
    - **JS 常用**：分离 Vendor 和 App 代码时，Vendor 不变，Hash 不变。
3.  **`contenthash`**：
    - 根据文件内容本身产生 Hash。
    - **CSS 常用**：CSS 从 JS 中提取出来后，如果 JS 变了但 CSS 没变，`contenthash` 能保证 CSS 文件名不变，利用缓存。

---

## 11. 实战：手写一个简单的 Loader

**题目**：写一个 Loader，将代码中的 "Hello" 替换为 "Hi"。

```javascript
// my-loader.js
// Loader 本质是一个函数，接收源码，返回转换后的源码
module.exports = function (source) {
  // 使用 this.getOptions() 获取配置参数 (Webpack 5 推荐 this.getOptions, 旧版用 loader-utils)
  const options = this.getOptions()

  // 处理源码
  const result = source.replace(/Hello/g, 'Hi')

  // 返回结果
  return result

  // 或者异步返回：
  // const callback = this.async();
  // setTimeout(() => callback(null, result), 1000);
}
```

---

## 12. 实战：手写一个简单的 Plugin

**题目**：写一个 Plugin，在构建结束时打印 "Build Finished!"。

```javascript
// MyPlugin.js
class MyPlugin {
  apply(compiler) {
    // 监听 'done' 钩子 (编译完成时触发)
    // Tapable 写法: .tap('插件名', 回调)
    compiler.hooks.done.tap('MyPlugin', (stats) => {
      console.log('Build Finished!')
    })

    // 监听 'emit' 钩子 (输出资源到目录前)
    compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
      // 可以在这里修改 compilation.assets 来修改最终输出的资源
      console.log('Emitting files...')
      callback()
    })
  }
}

module.exports = MyPlugin
```

---

## 13. 什么是 Module Federation (模块联邦)？

Webpack 5 的杀手级特性。它允许一个 Webpack 应用动态地加载另一个 Webpack 应用暴露的模块。

### 解决了什么问题？

- 传统的代码共享依靠 NPM 包，更新繁琐。
- 模块联邦实现了**运行时代码共享**。
- 是实现**微前端**架构的利器。

### 核心概念：

- **Host (宿主)**：引用其他应用模块的应用。
- **Remote (远程)**：暴露模块给其他应用的应用。
- **Shared (共享)**：依赖库（如 React），双方约定共享，避免加载两份。

---

## 14. 什么是 Tapable？

Webpack 的核心引擎。Webpack 本质上是一种事件流机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 Tapable。

- 它提供了一系列的**钩子 (Hooks)** 类：
  - `SyncHook` (同步)
  - `AsyncSeriesHook` (异步串行)
  - `AsyncParallelHook` (异步并行)
- `Compiler` 和 `Compilation` 对象都继承自 Tapable，它们身上挂载了大量的钩子。
- 插件 (Plugins) 的本质就是去发现这些钩子，用 `.tap` / `.tapAsync` 注册回调函数，从而在特定时机改变构建行为。
