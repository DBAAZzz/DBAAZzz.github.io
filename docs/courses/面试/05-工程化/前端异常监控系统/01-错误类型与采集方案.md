---
title: 错误类型与采集方案
author: DBAAZzz
date: 2026/01/03 20:55
categories:
  - 面试
tags:
  - 工程化
---

## 错误数据采集

- JS 代码运行时错误、代码错误
- 异步错误
- 静态资源加载错误
- 接口请求错误

## 错误捕获方式

### try/catch

**能力范围**：只能捕获代码常规的运行错误，**语法错误**和**异步错误**不能捕获到。

**适用场景**：

1. **JSON 解析**：防止非法 JSON 字符串导致程序崩溃

```js
try {
  const data = JSON.parse(userInput);
} catch (error) {
  console.error("JSON 解析失败:", error);
  // 上报错误
  reportError(error);
}
```

2. **第三方库调用**：隔离不可控的外部代码

```js
try {
  thirdPartyLib.doSomething();
} catch (error) {
  console.error("第三方库执行失败:", error);
  // 降级处理
  fallbackMethod();
}
```

3. **关键业务逻辑**：确保核心流程不被中断

```js
try {
  // 核心业务逻辑
  processPayment();
} catch (error) {
  // 记录错误但不影响其他功能
  reportError(error);
  showUserFriendlyMessage();
}
```

**与全局监控配合**：

```js
// 局部 try/catch 捕获后，仍可抛给全局监控
try {
  riskyOperation();
} catch (error) {
  // 1. 本地处理（如降级、用户提示）
  handleLocalError(error);

  // 2. 重新抛出，让全局监控捕获
  throw error;

  // 或者手动上报
  // window.reportError?.(error);
}
```

### window.onerror

**能力范围**：可以捕获常规错误、异步错误，但**不能捕获资源错误**。

**函数签名**：

```js
// message: 错误信息（字符串）
// source: 发生错误的脚本 URL
// lineno: 发生错误的行号
// colno: 发生错误的列号
// error: Error 对象（包含堆栈信息）
window.onerror = function (message, source, lineno, colno, error) {
  console.log("错误信息:", message);
  console.log("错误文件:", source);
  console.log("错误位置:", `${lineno}:${colno}`);
  console.log("错误堆栈:", error?.stack);

  // 上报错误
  reportError({
    message,
    source,
    lineno,
    colno,
    stack: error?.stack,
  });

  // 返回 true 阻止浏览器默认的错误处理（控制台输出）
  return true;
};
```

**实战示例**：

```js
// 1. 捕获同步错误
function syncError() {
  throw new Error("同步错误");
}
syncError(); // 可以捕获

// 2. 捕获异步错误
setTimeout(() => {
  throw new Error("异步错误");
}, 1000); // 可以捕获

// 3. 无法捕获资源加载错误
const img = new Image();
img.src = "https://invalid-url.com/image.jpg"; //  无法捕获
```

### window.addEventListener('error', callback)

**能力范围**：当静态资源加载失败时，会触发 error 事件，此时 `window.onerror` 不能捕获到。

**核心原理**：

- 资源加载错误**不会冒泡**，但会在**捕获阶段**触发
- 必须在 `addEventListener` 的第三个参数设置 `true` 或 `{ capture: true }`
- 通过 `event.target` 判断是资源错误还是 JS 错误

**完整实现**：

```js
window.addEventListener(
  "error",
  (event) => {
    // 区分 JS 错误和资源加载错误
    const target = event.target || event.srcElement;
    const isElementTarget = target !== window;

    if (isElementTarget) {
      // 资源加载错误
      const resourceType = target.tagName?.toLowerCase();
      const resourceUrl = target.src || target.href;

      console.error("资源加载失败:", {
        type: resourceType, // 'img', 'script', 'link', 'video' 等
        url: resourceUrl, // 资源 URL
        outerHTML: target.outerHTML.slice(0, 100), // 元素信息
        timestamp: Date.now(),
      });

      // 上报资源错误
      reportError({
        errorType: "resource",
        resourceType,
        resourceUrl,
        pageUrl: window.location.href,
      });

      // 降级处理
      handleResourceError(target, resourceType);
    } else {
      // JS 运行错误（也可以在这里处理）
      console.error("JS 错误:", {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack,
      });
    }
  },
  true
); // ⚠️ 必须设置为 true，在捕获阶段监听
```

**各类资源的错误处理**：

```js
function handleResourceError(target, type) {
  switch (type) {
    case "img":
      // 图片加载失败，使用占位图
      target.src = "/assets/placeholder.png";
      break;

    case "script":
      // 脚本加载失败，尝试从备用 CDN 加载
      const originalSrc = target.src;
      if (!originalSrc.includes("backup-cdn")) {
        const backupSrc = originalSrc.replace("cdn.com", "backup-cdn.com");
        const newScript = document.createElement("script");
        newScript.src = backupSrc;
        target.parentNode.replaceChild(newScript, target);
      }
      break;

    case "link":
      // CSS 加载失败，加载备用样式
      if (target.rel === "stylesheet") {
        console.warn("样式表加载失败，使用备用样式");
        // 可以加载本地备用样式
      }
      break;

    case "video":
    case "audio":
      // 媒体资源加载失败
      console.warn("媒体资源加载失败");
      break;
  }
}
```

**错误对象结构**：

```js
// 资源错误的 event 对象
{
  target: HTMLElement,        // 加载失败的元素
  type: 'error',             // 事件类型
  isTrusted: true,           // 是否是浏览器触发
  // 注意：资源错误没有 message、filename、lineno 等属性
}

// JS 错误的 event 对象
{
  message: '错误信息',
  filename: '文件路径',
  lineno: 行号,
  colno: 列号,
  error: Error 对象,
  type: 'error',
  target: window
}
```

### Promise 错误

**能力范围**：Promise 中抛出的错误，无法被 `window.onerror`、`try/catch`、`error` 事件捕获到，可通过 `unhandledrejection` 事件来处理。

**基础用法**：

```js
window.addEventListener("unhandledrejection", (event) => {
  console.log("Promise 错误:", event.reason); // 错误原因
  console.log("Promise 对象:", event.promise); // 被拒绝的 Promise

  // 阻止浏览器默认的错误处理（控制台红色错误）
  event.preventDefault();
});
```

**event 对象详解**：

```js
window.addEventListener("unhandledrejection", (event) => {
  // event.reason: 拒绝原因（可能是 Error 对象或任意值）
  const reason = event.reason;

  // event.promise: 被拒绝的 Promise 对象
  const promise = event.promise;

  // 构建错误信息
  const errorInfo = {
    type: "unhandledrejection",
    reason: reason instanceof Error ? reason.message : String(reason),
    stack: reason?.stack,
    promise: promise.toString(),
    timestamp: Date.now(),
  };

  console.error("未处理的 Promise 拒绝:", errorInfo);

  // 上报错误
  reportError(errorInfo);

  // 阻止默认行为
  event.preventDefault();
});
```

**async/await 的特殊性**：

async 函数中未捕获的错误会触发 unhandledrejection

```js
async function fetchData() {
  throw new Error("Async 错误");
}
fetchData(); // 触发 unhandledrejection

// 使用 try/catch 捕获
async function fetchDataSafe() {
  try {
    throw new Error("Async 错误");
  } catch (error) {
    console.error("捕获到错误:", error);
  }
}

// 或者在调用时捕获
fetchData().catch((error) => {
  console.error("捕获到错误:", error);
});
```

**避免重复上报**：

```js
class PromiseErrorMonitor {
  constructor() {
    this.reportedErrors = new WeakSet(); // 使用 WeakSet 避免内存泄漏
    this.init();
  }

  init() {
    // 监听未处理的 Promise 拒绝
    window.addEventListener("unhandledrejection", (event) => {
      this.handleUnhandledRejection(event);
    });

    // 监听后续被处理的 Promise 拒绝
    window.addEventListener("rejectionhandled", (event) => {
      this.handleRejectionHandled(event);
    });
  }

  handleUnhandledRejection(event) {
    const { reason, promise } = event;

    // 避免重复上报同一个 Promise
    if (this.reportedErrors.has(promise)) {
      return;
    }

    this.reportedErrors.add(promise);

    const errorInfo = {
      type: "unhandledrejection",
      message: reason instanceof Error ? reason.message : String(reason),
      stack: reason?.stack,
      timestamp: Date.now(),
    };

    console.error("未处理的 Promise 错误:", errorInfo);
    this.report(errorInfo);

    event.preventDefault();
  }

  handleRejectionHandled(event) {
    // Promise 后续被 .catch() 处理了
    console.log("Promise 错误已被处理:", event.promise);

    // 可以选择撤销之前的错误上报（如果支持）
    // 或者标记该错误已被处理
  }

  report(errorInfo) {
    // 上报逻辑
    console.log("上报 Promise 错误:", errorInfo);
  }
}

new PromiseErrorMonitor();
```

**rejectionhandled 事件的配合使用**：

```js
// 场景：Promise 先被拒绝，后来才添加 .catch() 处理
const promise = Promise.reject("延迟处理的错误");

// 1 秒后触发 unhandledrejection
setTimeout(() => {
  // 2 秒后添加 .catch()，触发 rejectionhandled
  setTimeout(() => {
    promise.catch((err) => {
      console.log("延迟处理:", err);
    });
  }, 1000);
}, 1000);

// 监听流程
window.addEventListener("unhandledrejection", (event) => {
  console.log("1. 未处理的拒绝:", event.reason);
});

window.addEventListener("rejectionhandled", (event) => {
  console.log("2. 拒绝已被处理:", event.reason);
  // 可以在这里撤销之前的错误上报
});
```

**完整的 Promise 错误监控方案**：

```js
class PromiseMonitor {
  constructor(options = {}) {
    this.options = {
      reportDelay: 2000, // 延迟上报，给代码添加 .catch() 的机会
      ...options,
    };
    this.pendingErrors = new Map(); // 待上报的错误
    this.init();
  }

  init() {
    window.addEventListener("unhandledrejection", (event) => {
      this.scheduleReport(event);
      event.preventDefault();
    });

    window.addEventListener("rejectionhandled", (event) => {
      this.cancelReport(event.promise);
    });
  }

  scheduleReport(event) {
    const { reason, promise } = event;

    // 延迟上报，给代码添加 .catch() 的机会
    const timerId = setTimeout(() => {
      this.report({
        type: "unhandledrejection",
        message: reason instanceof Error ? reason.message : String(reason),
        stack: reason?.stack,
        timestamp: Date.now(),
      });

      this.pendingErrors.delete(promise);
    }, this.options.reportDelay);

    this.pendingErrors.set(promise, timerId);
  }

  cancelReport(promise) {
    const timerId = this.pendingErrors.get(promise);
    if (timerId) {
      clearTimeout(timerId);
      this.pendingErrors.delete(promise);
      console.log("Promise 错误已被处理，取消上报");
    }
  }

  report(errorInfo) {
    console.log("上报 Promise 错误:", errorInfo);
    // 实际上报逻辑
  }
}

new PromiseMonitor({ reportDelay: 2000 });
```

**最佳实践**：

```js
// 1. 始终为 Promise 添加 .catch()
fetch("/api/data")
  .then((res) => res.json())
  .catch((err) => console.error("请求失败:", err));

// 2. async 函数使用 try/catch
async function getData() {
  try {
    const res = await fetch("/api/data");
    return await res.json();
  } catch (error) {
    console.error("获取数据失败:", error);
    throw error; // 可以选择重新抛出
  }
}

// 3. 顶层 async 函数添加错误处理
(async () => {
  try {
    await main();
  } catch (error) {
    console.error("应用启动失败:", error);
  }
})();
```

### Vue 错误

**能力范围**：Vue 通过 `Vue.config.errorHandler` 来捕获组件内的异常。

**核心原理**：

Vue 在执行用户代码（生命周期钩子、事件处理器、渲染函数等）时，都会用 `callWithErrorHandling` 包装，异步错误则通过 `callWithAsyncErrorHandling` 捕获 Promise rejection。

因为 Vue 内部所有执行用户代码的地方都使用了这套包装机制，包括：

- 生命周期钩子执行
- 渲染函数调用
- 事件处理器触发
- watch 回调执行
- 指令钩子调用
- 调度器任务执行

这确保了无论错误在哪里发生，都会流经同一个处理管道。

**Vue 2 完整配置**：

```js
// main.js
import Vue from "vue";

Vue.config.errorHandler = function (err, vm, info) {
  // err: 错误对象
  // vm: 发生错误的 Vue 组件实例
  // info: Vue 特定的错误信息，如生命周期钩子名称

  console.error("Vue 错误捕获:", {
    message: err.message,
    stack: err.stack,
    componentName: vm?.$options?.name || vm?.$options?._componentTag,
    propsData: vm?.$options?.propsData,
    info, // 'mounted hook', 'render', 'v-on handler' 等
    route: vm?.$route?.path, // 当前路由
    timestamp: Date.now(),
  });

  // 上报错误
  reportError({
    type: "vue",
    message: err.message,
    stack: err.stack,
    componentName: vm?.$options?.name,
    info,
    route: vm?.$route?.path,
  });

  // 可以选择是否继续抛出错误
  // throw err;
};

// 同时处理 Vue 警告
Vue.config.warnHandler = function (msg, vm, trace) {
  console.warn("Vue 警告:", msg, trace);
  // 可以选择上报警告
};
```

**Vue 3 的变化**：

```js
// main.js
import { createApp } from "vue";
import App from "./App.vue";

const app = createApp(App);

// Vue 3 中使用 app.config.errorHandler
app.config.errorHandler = (err, instance, info) => {
  // err: 错误对象
  // instance: 发生错误的组件实例
  // info: 错误信息字符串

  console.error("Vue 3 错误捕获:", {
    message: err.message,
    stack: err.stack,
    componentName: instance?.$options?.name || instance?.$.type?.name,
    props: instance?.$props,
    info,
    timestamp: Date.now(),
  });

  // 上报错误
  reportError({
    type: "vue",
    message: err.message,
    stack: err.stack,
    componentName: instance?.$.type?.name,
    info,
  });
};

// Vue 3 警告处理
app.config.warnHandler = (msg, instance, trace) => {
  console.warn("Vue 3 警告:", msg, trace);
};

app.mount("#app");
```

**获取详细的组件信息**：

```js
function getComponentInfo(vm) {
  if (!vm) return {};

  // Vue 2
  if (vm.$options) {
    return {
      name: vm.$options.name || vm.$options._componentTag,
      propsData: vm.$options.propsData,
      data: vm.$data,
      computed: vm._computedWatchers,
      route: vm.$route?.path,
      parent: vm.$parent?.$options?.name,
    };
  }

  // Vue 3
  if (vm.$) {
    return {
      name: vm.$.type?.name,
      props: vm.$props,
      data: vm.$data,
      route: vm.$route?.path,
      parent: vm.$.parent?.type?.name,
    };
  }

  return {};
}

// 使用
Vue.config.errorHandler = function (err, vm, info) {
  const componentInfo = getComponentInfo(vm);
  console.error("组件错误:", { err, componentInfo, info });
};
```

**与 Vue Router 的错误处理结合**：

```js
import { createRouter } from "vue-router";

const router = createRouter({
  // ... 路由配置
});

// 路由错误处理
router.onError((error) => {
  console.error("路由错误:", error);

  reportError({
    type: "router",
    message: error.message,
    stack: error.stack,
    route: router.currentRoute.value.path,
  });
});

// 导航守卫中的错误处理
router.beforeEach((to, from, next) => {
  try {
    // 路由守卫逻辑
    next();
  } catch (error) {
    console.error("导航守卫错误:", error);
    reportError({
      type: "navigation-guard",
      message: error.message,
      from: from.path,
      to: to.path,
    });
    next(false);
  }
});
```

**与 Pinia 的错误处理结合**：

```js
import { createPinia } from "pinia";

const pinia = createPinia();

// Pinia 插件：捕获 action 中的错误
pinia.use(({ store }) => {
  // 包装所有 actions
  Object.keys(store.$options.actions || {}).forEach((actionName) => {
    const originalAction = store[actionName];

    store[actionName] = async function (...args) {
      try {
        return await originalAction.apply(this, args);
      } catch (error) {
        console.error(`Store action 错误 [${store.$id}.${actionName}]:`, error);

        reportError({
          type: "pinia-action",
          store: store.$id,
          action: actionName,
          message: error.message,
          stack: error.stack,
        });

        throw error; // 重新抛出，让上层处理
      }
    };
  });
});
```

### 跨域脚本错误处理

**问题现象**：当加载跨域的 JS 脚本出错时，`window.onerror` 默认只能捕获到 `"Script Error"`，而无法获取详细的报错信息（堆栈、行列号）。

**原因分析**：

这是浏览器的**安全策略**（CORS 策略），防止恶意网站通过错误信息窃取跨域脚本的内容。

```js
// 跨域脚本错误的表现
window.onerror = function (message, source, lineno, colno, error) {
  console.log(message); // "Script error."
  console.log(source); // ""
  console.log(lineno); // 0
  console.log(colno); // 0
  console.log(error); // null
};
```

**解决方案**：

需要**同时满足**以下两个条件：

1. **前端**：在 `<script>` 标签添加 `crossorigin` 属性
2. **后端**：服务器响应头配置 `Access-Control-Allow-Origin`

**前端配置**：

```html
<!--  正确：添加 crossorigin 属性 -->
<script src="https://cdn.example.com/app.js" crossorigin="anonymous"></script>

<!--  错误：没有 crossorigin 属性 -->
<script src="https://cdn.example.com/app.js"></script>
```

**crossorigin 属性的可选值**：

| 值                | 说明                                | 使用场景               |
| ----------------- | ----------------------------------- | ---------------------- |
| `anonymous`       | 不发送用户凭证（Cookie、HTTP 认证） | 大多数场景（推荐）     |
| `use-credentials` | 发送用户凭证                        | 需要携带 Cookie 的场景 |

```html
<!-- 匿名模式（推荐） -->
<script src="https://cdn.example.com/app.js" crossorigin="anonymous"></script>

<!-- 携带凭证模式 -->
<script
  src="https://cdn.example.com/app.js"
  crossorigin="use-credentials"
></script>
```

**后端配置**：

```nginx
# Nginx 配置
location ~* \.(js|css)$ {
    # 允许所有域名访问（生产环境建议指定具体域名）
    add_header Access-Control-Allow-Origin *;

    # 或者指定具体域名
    # add_header Access-Control-Allow-Origin https://www.example.com;

    # 如果使用 use-credentials，必须指定具体域名，不能用 *
    # add_header Access-Control-Allow-Origin https://www.example.com;
    # add_header Access-Control-Allow-Credentials true;
}
```

```js
// Node.js Express 配置
app.use((req, res, next) => {
  // 允许所有域名
  res.setHeader("Access-Control-Allow-Origin", "*");

  // 或者指定具体域名
  // res.setHeader('Access-Control-Allow-Origin', 'https://www.example.com');

  // 如果前端使用 crossorigin="use-credentials"
  // res.setHeader('Access-Control-Allow-Origin', req.headers.origin);
  // res.setHeader('Access-Control-Allow-Credentials', 'true');

  next();
});
```

**CDN 资源配置示例**：

```html
<!-- 常见 CDN 都已支持 CORS -->
<script
  src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"
  crossorigin="anonymous"
></script>

<script
  src="https://unpkg.com/react@18/umd/react.production.min.js"
  crossorigin="anonymous"
></script>
```

**动态加载脚本的处理**：

```js
function loadScript(url) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = url;

    // ⚠️ 关键：设置 crossorigin 属性
    script.crossOrigin = "anonymous";

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Script load error: ${url}`));

    document.head.appendChild(script);
  });
}

// 使用
loadScript("https://cdn.example.com/app.js")
  .then(() => console.log("脚本加载成功"))
  .catch((err) => console.error("脚本加载失败:", err));
```

**验证配置是否生效**：

```js
// 方法 1：检查错误信息
window.onerror = function (message, source, lineno, colno, error) {
  if (message === "Script error." && !source && !lineno) {
    console.error(" 跨域配置未生效，仍然是 Script Error");
  } else {
    console.log(" 跨域配置生效，可以获取详细错误信息");
    console.log("错误信息:", message);
    console.log("错误文件:", source);
    console.log("错误位置:", `${lineno}:${colno}`);
    console.log("错误堆栈:", error?.stack);
  }
};

// 方法 2：检查网络请求
// 打开浏览器开发者工具 -> Network -> 查看脚本请求
// Response Headers 应该包含：Access-Control-Allow-Origin: *
```

**降级方案**：

当无法配置 CORS 时（如第三方 CDN 不支持），可以采用以下降级方案：

```js
class ScriptErrorHandler {
  constructor() {
    this.scriptErrors = new Map();
    this.init();
  }

  init() {
    // 监听资源加载错误
    window.addEventListener(
      "error",
      (event) => {
        const target = event.target;

        if (target.tagName === "SCRIPT") {
          // 记录脚本加载失败
          this.scriptErrors.set(target.src, {
            url: target.src,
            timestamp: Date.now(),
            hasCrossOrigin: target.hasAttribute("crossorigin"),
          });
        }
      },
      true
    );

    // 监听 JS 错误
    window.onerror = (message, source, lineno, colno, error) => {
      if (message === "Script error." && !source) {
        // 跨域脚本错误，尝试推断来源
        const possibleScript = this.findPossibleScript();

        console.error("跨域脚本错误（降级处理）:", {
          message: "Script error (CORS blocked)",
          possibleSource: possibleScript?.url,
          suggestion: '请在 script 标签添加 crossorigin="anonymous"',
          timestamp: Date.now(),
        });

        // 上报降级信息
        reportError({
          type: "script-error-cors-blocked",
          possibleSource: possibleScript?.url,
          timestamp: Date.now(),
        });
      } else {
        // 正常错误处理
        console.error("JS 错误:", { message, source, lineno, colno, error });
      }
    };
  }

  findPossibleScript() {
    // 查找最近加载失败的脚本
    const scripts = Array.from(this.scriptErrors.values());
    return scripts.sort((a, b) => b.timestamp - a.timestamp)[0];
  }
}

new ScriptErrorHandler();
```

### console.error 劫持

**问题背景**：很多三方库或框架内部会自行 catch 错误并调用 `console.error` 打印，而不会抛出全局 `onerror` 或 `unhandledrejection`，导致监控系统漏测。

**解决方案**：重写 `console.error`，将错误信息上报。

**基础实现**：

```js
// 保存原始方法
const originalConsoleError = console.error;

// 重写 console.error
console.error = function (...args) {
  // 1. 调用原始方法，保持正常的控制台输出
  originalConsoleError.apply(console, args);

  // 2. 提取错误信息
  const errorInfo = {
    type: "console.error",
    message: args
      .map((arg) => {
        if (arg instanceof Error) {
          return arg.message;
        }
        return String(arg);
      })
      .join(" "),
    stack: args.find((arg) => arg instanceof Error)?.stack,
    arguments: args,
    timestamp: Date.now(),
  };

  // 3. 上报错误
  reportError(errorInfo);
};
```

**完整的 console 劫持方案**：

```js
class ConsoleMonitor {
  constructor(options = {}) {
    this.options = {
      methods: ["error", "warn"], // 需要劫持的方法
      reportConsoleLog: false, // 是否上报 console.log
      maxStackDepth: 10, // 最大堆栈深度
      ...options,
    };

    this.originalMethods = {};
    this.isReporting = false; // 防止循环调用
    this.init();
  }

  init() {
    this.options.methods.forEach((method) => {
      this.hijackConsoleMethod(method);
    });

    if (this.options.reportConsoleLog) {
      this.hijackConsoleMethod("log");
    }
  }

  hijackConsoleMethod(method) {
    // 保存原始方法
    this.originalMethods[method] = console[method];

    const self = this;

    // 重写方法
    console[method] = function (...args) {
      // 调用原始方法
      self.originalMethods[method].apply(console, args);

      // 避免在上报过程中再次触发 console.error
      if (self.isReporting) {
        return;
      }

      try {
        self.isReporting = true;
        self.handleConsoleCall(method, args);
      } finally {
        self.isReporting = false;
      }
    };
  }

  handleConsoleCall(method, args) {
    // 提取错误信息
    const errorInfo = this.extractErrorInfo(method, args);

    // 过滤噪音（可选）
    if (this.shouldReport(errorInfo)) {
      this.report(errorInfo);
    }
  }

  extractErrorInfo(method, args) {
    // 查找 Error 对象
    const errorObj = args.find((arg) => arg instanceof Error);

    // 构建错误信息
    const message = args
      .map((arg) => {
        if (arg instanceof Error) {
          return arg.message;
        }
        if (typeof arg === "object") {
          try {
            return JSON.stringify(arg);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      })
      .join(" ");

    return {
      type: `console.${method}`,
      method,
      message,
      stack: errorObj?.stack || this.getStackTrace(),
      arguments: this.serializeArguments(args),
      timestamp: Date.now(),
      url: window.location.href,
    };
  }

  getStackTrace() {
    // 获取当前调用堆栈
    try {
      throw new Error();
    } catch (e) {
      // 移除前几行（ConsoleMonitor 内部的堆栈）
      const stack = e.stack.split("\n");
      return stack.slice(4, 4 + this.options.maxStackDepth).join("\n");
    }
  }

  serializeArguments(args) {
    // 序列化参数，避免循环引用
    return args.map((arg) => {
      if (arg instanceof Error) {
        return {
          type: "Error",
          message: arg.message,
          stack: arg.stack,
        };
      }
      if (typeof arg === "object") {
        try {
          return JSON.parse(JSON.stringify(arg)); // 深拷贝并去除循环引用
        } catch (e) {
          return String(arg);
        }
      }
      return arg;
    });
  }

  shouldReport(errorInfo) {
    // 过滤规则（可自定义）

    // 1. 过滤特定的错误消息
    const ignorePatterns = [
      /ResizeObserver loop/,
      /Non-Error promise rejection/,
    ];

    if (ignorePatterns.some((pattern) => pattern.test(errorInfo.message))) {
      return false;
    }

    // 2. 过滤来自浏览器插件的错误
    if (errorInfo.stack?.includes("chrome-extension://")) {
      return false;
    }

    return true;
  }

  report(errorInfo) {
    // 上报逻辑
    console.log("[ConsoleMonitor] 上报错误:", errorInfo);

    // 实际上报
    // reportError(errorInfo);
  }

  restore() {
    // 恢复原始方法
    Object.keys(this.originalMethods).forEach((method) => {
      console[method] = this.originalMethods[method];
    });
  }
}

// 使用
const consoleMonitor = new ConsoleMonitor({
  methods: ["error", "warn"],
  reportConsoleLog: false,
});

// 如需恢复
// consoleMonitor.restore();
```

**处理堆栈信息**：

```js
// 从堆栈中提取有用信息
function parseStackTrace(stack) {
  if (!stack) return [];

  const lines = stack.split("\n");
  const frames = [];

  // 匹配堆栈格式：at functionName (file:line:column)
  const stackRegex = /at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/;

  for (const line of lines) {
    const match = line.match(stackRegex);
    if (match) {
      frames.push({
        function: match[1],
        file: match[2],
        line: parseInt(match[3]),
        column: parseInt(match[4]),
      });
    }
  }

  return frames;
}

// 使用
const stack = parseStackTrace(error.stack);
console.log("堆栈帧:", stack);
```

**与 SourceMap 结合**：

```js
class ConsoleMonitorWithSourceMap extends ConsoleMonitor {
  async handleConsoleCall(method, args) {
    const errorInfo = this.extractErrorInfo(method, args);

    // 如果有堆栈信息，尝试还原
    if (errorInfo.stack) {
      errorInfo.originalStack = await this.restoreStackTrace(errorInfo.stack);
    }

    if (this.shouldReport(errorInfo)) {
      this.report(errorInfo);
    }
  }

  async restoreStackTrace(stack) {
    // 解析堆栈
    const frames = parseStackTrace(stack);

    // 还原每一帧（需要 SourceMap 库，如 source-map）
    const restoredFrames = await Promise.all(
      frames.map((frame) => this.restoreFrame(frame))
    );

    return restoredFrames;
  }

  async restoreFrame(frame) {
    // 这里需要集成 SourceMap 解析逻辑
    // 实际项目中通常在服务端处理
    return frame;
  }
}
```

**性能优化**：

```js
class OptimizedConsoleMonitor extends ConsoleMonitor {
  constructor(options = {}) {
    super(options);
    this.reportQueue = [];
    this.reportTimer = null;
    this.batchSize = options.batchSize || 10;
    this.batchInterval = options.batchInterval || 5000; // 5秒
  }

  report(errorInfo) {
    // 批量上报
    this.reportQueue.push(errorInfo);

    if (this.reportQueue.length >= this.batchSize) {
      this.flushReports();
    } else if (!this.reportTimer) {
      this.reportTimer = setTimeout(() => {
        this.flushReports();
      }, this.batchInterval);
    }
  }

  flushReports() {
    if (this.reportQueue.length === 0) return;

    const reports = this.reportQueue.splice(0);

    console.log("[ConsoleMonitor] 批量上报:", reports.length, "条错误");

    // 实际上报
    // reportErrors(reports);

    if (this.reportTimer) {
      clearTimeout(this.reportTimer);
      this.reportTimer = null;
    }
  }
}
```

**最佳实践**：

```js
// 1. 在应用初始化时尽早劫持
const consoleMonitor = new ConsoleMonitor({
  methods: ["error", "warn"],
  reportConsoleLog: false,
});

// 2. 避免劫持 console.log（性能影响大）
// 除非有特殊需求

// 3. 添加过滤规则，减少噪音
// 在 shouldReport 方法中实现

// 4. 使用批量上报，减少网络请求
// 使用 OptimizedConsoleMonitor

// 5. 在开发环境可以禁用上报
if (process.env.NODE_ENV === "production") {
  new ConsoleMonitor();
}
```

**注意事项**：

```js
// ⚠️ 避免循环调用
console.error = function (...args) {
  originalConsoleError.apply(console, args);

  //  错误：如果 reportError 内部使用了 console.error，会导致无限循环
  reportError({ message: args[0] });
};

//  正确：使用标志位防止循环
let isReporting = false;
console.error = function (...args) {
  originalConsoleError.apply(console, args);

  if (!isReporting) {
    isReporting = true;
    try {
      reportError({ message: args[0] });
    } finally {
      isReporting = false;
    }
  }
};
```

### React 错误边界

**能力范围**：React 16+ 提供了 `componentDidCatch` 和 `static getDerivedStateFromError` 生命周期，类似于 Vue 的 `errorHandler`，用于捕获子组件树中的渲染错误。

**两个生命周期的区别**：

| 特性     | getDerivedStateFromError | componentDidCatch                       |
| -------- | ------------------------ | --------------------------------------- |
| 调用时机 | 渲染阶段                 | 提交阶段（commit phase）                |
| 用途     | 更新 state，渲染降级 UI  | 记录错误信息、上报错误                  |
| 副作用   | 不允许副作用             | 允许副作用                              |
| 参数     | error                    | error, errorInfo（包含 componentStack） |

**基础实现**：

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  // 1. 更新 state，渲染降级 UI
  static getDerivedStateFromError(error) {
    // 在渲染阶段调用，不能有副作用
    return { hasError: true, error };
  }

  // 2. 记录错误信息，上报错误
  componentDidCatch(error, errorInfo) {
    // 在提交阶段调用，可以有副作用
    console.error("捕获到错误:", error);
    console.error("组件堆栈:", errorInfo.componentStack);

    // 上报错误
    reportError({
      type: "react",
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: Date.now(),
    });
  }

  render() {
    if (this.state.hasError) {
      // 降级 UI
      return (
        <div className="error-fallback">
          <h2>出错了</h2>
          <p>{this.state.error?.message}</p>
          <button onClick={() => this.setState({ hasError: false })}>
            重试
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 使用
function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

**错误边界的局限性**：

错误边界**不能**捕获以下错误：

```jsx
//  1. 事件处理器中的错误
function MyComponent() {
  const handleClick = () => {
    throw new Error("事件处理器错误"); // 不会被捕获
  };

  return <button onClick={handleClick}>点击</button>;
}

//  解决方案：使用 try/catch
function MyComponent() {
  const handleClick = () => {
    try {
      throw new Error("事件处理器错误");
    } catch (error) {
      reportError(error);
    }
  };

  return <button onClick={handleClick}>点击</button>;
}

//  2. 异步代码（setTimeout、Promise）
function MyComponent() {
  useEffect(() => {
    setTimeout(() => {
      throw new Error("异步错误"); // 不会被捕获
    }, 1000);
  }, []);

  return <div>组件</div>;
}

//  解决方案：使用 window.onerror 或 unhandledrejection

//  3. 服务端渲染（SSR）
// 错误边界只在客户端有效

//  4. 错误边界自身的错误
class ErrorBoundary extends React.Component {
  render() {
    throw new Error("错误边界自身的错误"); // 不会被捕获
    return this.props.children;
  }
}
```

**react-error-boundary 库**：

社区事实标准库，内部封装了类组件，但对外提供了非常符合 Hook 直觉的 API。

```bash
npm install react-error-boundary
```

**基础使用**：

```jsx
import { ErrorBoundary } from "react-error-boundary";

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert">
      <p>出错了：</p>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>重试</button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onError={(error, errorInfo) => {
        // 上报错误
        console.error("错误:", error);
        console.error("错误信息:", errorInfo);
      }}
      onReset={() => {
        // 重置应用状态
        console.log("重置");
      }}
    >
      <MyComponent />
    </ErrorBoundary>
  );
}
```

**使用 useErrorHandler Hook**：

```jsx
import { useErrorHandler } from "react-error-boundary";

function MyComponent() {
  const handleError = useErrorHandler();

  const handleClick = async () => {
    try {
      await fetchData();
    } catch (error) {
      // 将错误传递给最近的错误边界
      handleError(error);
    }
  };

  return <button onClick={handleClick}>获取数据</button>;
}

// 配合 ErrorBoundary 使用
function App() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

**错误边界的粒度设计**：

```jsx
// 1. 全局错误边界（兜底）
function App() {
  return (
    <ErrorBoundary
      FallbackComponent={GlobalErrorFallback}
      onError={reportError}
    >
      <Router>
        <Routes />
      </Router>
    </ErrorBoundary>
  );
}

// 2. 页面级错误边界
function Routes() {
  return (
    <Switch>
      <Route path="/home">
        <ErrorBoundary FallbackComponent={PageErrorFallback}>
          <HomePage />
        </ErrorBoundary>
      </Route>
      <Route path="/profile">
        <ErrorBoundary FallbackComponent={PageErrorFallback}>
          <ProfilePage />
        </ErrorBoundary>
      </Route>
    </Switch>
  );
}

// 3. 组件级错误边界（细粒度）
function HomePage() {
  return (
    <div>
      <Header />

      {/* 侧边栏错误不影响主内容 */}
      <ErrorBoundary FallbackComponent={SidebarErrorFallback}>
        <Sidebar />
      </ErrorBoundary>

      {/* 主内容错误不影响侧边栏 */}
      <ErrorBoundary FallbackComponent={ContentErrorFallback}>
        <MainContent />
      </ErrorBoundary>
    </div>
  );
}
```

**与监控系统集成**：

```jsx
import { ErrorBoundary } from "react-error-boundary";

// 创建统一的错误处理函数
function handleError(error, errorInfo) {
  // 构建错误信息
  const errorData = {
    type: "react-error-boundary",
    message: error.message,
    stack: error.stack,
    componentStack: errorInfo.componentStack,

    // 添加上下文信息
    route: window.location.pathname,
    userAgent: navigator.userAgent,
    timestamp: Date.now(),

    // 用户信息（如果有）
    userId: getCurrentUserId(),

    // 应用版本
    version: process.env.REACT_APP_VERSION,
  };

  // 上报到监控系统
  reportError(errorData);

  // 也可以上报到第三方服务（如 Sentry）
  // Sentry.captureException(error, { contexts: { react: errorInfo } });
}

// 创建可复用的错误边界组件
function MonitoredErrorBoundary({ children, fallback, level = "component" }) {
  return (
    <ErrorBoundary
      FallbackComponent={fallback || DefaultErrorFallback}
      onError={(error, errorInfo) => {
        handleError(error, {
          ...errorInfo,
          level, // 标记错误级别
        });
      }}
      onReset={() => {
        // 重置时的处理
        console.log(`[${level}] 错误边界重置`);
      }}
    >
      {children}
    </ErrorBoundary>
  );
}

// 使用
function App() {
  return (
    <MonitoredErrorBoundary level="global" fallback={GlobalErrorFallback}>
      <Router>
        <MonitoredErrorBoundary level="page" fallback={PageErrorFallback}>
          <HomePage />
        </MonitoredErrorBoundary>
      </Router>
    </MonitoredErrorBoundary>
  );
}
```

**完整的错误监控方案**：

```jsx
// errorMonitoring.js
import { ErrorBoundary } from "react-error-boundary";

// 错误上报函数
export function reportReactError(error, errorInfo, context = {}) {
  const errorData = {
    type: "react",
    message: error.message,
    stack: error.stack,
    componentStack: errorInfo.componentStack,

    // 上下文信息
    ...context,
    route: window.location.pathname,
    timestamp: Date.now(),
  };

  // 发送到监控服务
  fetch("/api/errors", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(errorData),
  }).catch((err) => {
    console.error("错误上报失败:", err);
  });
}

// 全局错误边界
export function GlobalErrorBoundary({ children }) {
  return (
    <ErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) => (
        <div className="global-error">
          <h1>应用出错了</h1>
          <p>{error.message}</p>
          <button onClick={resetErrorBoundary}>重新加载</button>
        </div>
      )}
      onError={(error, errorInfo) => {
        reportReactError(error, errorInfo, { level: "global" });
      }}
      onReset={() => {
        // 重置应用状态
        window.location.href = "/";
      }}
    >
      {children}
    </ErrorBoundary>
  );
}

// 页面级错误边界
export function PageErrorBoundary({ children, pageName }) {
  return (
    <ErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) => (
        <div className="page-error">
          <h2>页面加载失败</h2>
          <p>{error.message}</p>
          <button onClick={resetErrorBoundary}>重试</button>
        </div>
      )}
      onError={(error, errorInfo) => {
        reportReactError(error, errorInfo, {
          level: "page",
          pageName,
        });
      }}
    >
      {children}
    </ErrorBoundary>
  );
}

// 组件级错误边界
export function ComponentErrorBoundary({ children, componentName }) {
  return (
    <ErrorBoundary
      FallbackComponent={() => (
        <div className="component-error">
          <p>组件加载失败</p>
        </div>
      )}
      onError={(error, errorInfo) => {
        reportReactError(error, errorInfo, {
          level: "component",
          componentName,
        });
      }}
    >
      {children}
    </ErrorBoundary>
  );
}
```

**最佳实践**：

```jsx
// 1. 多层错误边界，细粒度控制
function App() {
  return (
    <GlobalErrorBoundary>
      <Router>
        <PageErrorBoundary pageName="home">
          <HomePage />
        </PageErrorBoundary>
      </Router>
    </GlobalErrorBoundary>
  );
}

// 2. 配合 React.lazy 使用
const LazyComponent = React.lazy(() => import("./LazyComponent"));

function App() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <Suspense fallback={<Loading />}>
        <LazyComponent />
      </Suspense>
    </ErrorBoundary>
  );
}

// 3. 提供重置机制
function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div>
      <p>错误: {error.message}</p>
      <button onClick={resetErrorBoundary}>重试</button>
      <button onClick={() => (window.location.href = "/")}>回到首页</button>
    </div>
  );
}

// 4. 结合 useErrorHandler 处理异步错误
function MyComponent() {
  const handleError = useErrorHandler();

  useEffect(() => {
    fetchData().catch(handleError);
  }, [handleError]);

  return <div>组件内容</div>;
}
```

### 网页崩溃

**问题背景**：当页面发生 Crash（如内存溢出 OOM）时，JS 主线程挂掉，`window.onerror` 等常规手段完全失效。

**监控原理**：

1. **Service Worker 心跳检测**：主线程与 Worker 保持定时心跳，如果 Worker 长时间未收到心跳，则判定主线程 Crash。
2. **load/beforeunload 标记法**：用 `sessionStorage` 记录页面状态。页面加载时存入标记，`beforeunload` 时清除标记。若下次进入页面发现标记仍在，说明上次是非正常退出（Crash）。

---

#### 方案一：Service Worker 心跳检测

**核心原理**：

- Service Worker 运行在独立的线程，不受主线程崩溃影响
- 主线程定时向 Service Worker 发送心跳
- Service Worker 检测心跳超时，判定为崩溃

**完整实现**：

```js
// 1. 注册 Service Worker（主线程）
// main.js
if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("/crash-monitor-sw.js")
    .then((registration) => {
      console.log("Service Worker 注册成功");

      // 启动心跳
      startHeartbeat(registration);
    })
    .catch((err) => {
      console.error("Service Worker 注册失败:", err);
    });
}

// 2. 心跳发送逻辑
function startHeartbeat(registration) {
  const HEARTBEAT_INTERVAL = 5000; // 5秒发送一次心跳

  setInterval(() => {
    if (registration.active) {
      // 向 Service Worker 发送心跳消息
      registration.active.postMessage({
        type: "heartbeat",
        timestamp: Date.now(),
        pageUrl: window.location.href,
        userId: getCurrentUserId(), // 用户信息
      });
    }
  }, HEARTBEAT_INTERVAL);
}

// 3. Service Worker 心跳检测逻辑
// crash-monitor-sw.js
const HEARTBEAT_TIMEOUT = 15000; // 15秒未收到心跳视为崩溃
const heartbeatMap = new Map(); // 存储各页面的心跳时间

// 监听主线程消息
self.addEventListener("message", (event) => {
  const { type, timestamp, pageUrl, userId } = event.data;

  if (type === "heartbeat") {
    // 更新心跳时间
    const clientId = event.source.id;
    heartbeatMap.set(clientId, {
      timestamp,
      pageUrl,
      userId,
      lastHeartbeat: Date.now(),
    });
  }
});

// 定时检查心跳超时
setInterval(() => {
  const now = Date.now();

  heartbeatMap.forEach((info, clientId) => {
    const timeSinceLastHeartbeat = now - info.lastHeartbeat;

    if (timeSinceLastHeartbeat > HEARTBEAT_TIMEOUT) {
      // 检测到崩溃
      console.error("检测到页面崩溃:", info);

      // 上报崩溃信息
      reportCrash({
        type: "page-crash",
        pageUrl: info.pageUrl,
        userId: info.userId,
        lastHeartbeat: info.lastHeartbeat,
        crashTime: now,
        userAgent: navigator.userAgent,
      });

      // 移除该客户端
      heartbeatMap.delete(clientId);
    }
  });
}, 5000); // 每5秒检查一次

// 上报崩溃信息
function reportCrash(crashInfo) {
  // 使用 fetch 上报（Service Worker 中可用）
  fetch("/api/crash-report", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(crashInfo),
  }).catch((err) => {
    console.error("崩溃上报失败:", err);
  });
}

// 监听客户端断开连接
self.addEventListener("message", (event) => {
  if (event.data.type === "page-close") {
    // 正常关闭，移除心跳记录
    heartbeatMap.delete(event.source.id);
  }
});
```

**页面卸载时通知 Service Worker**：

```js
// main.js
window.addEventListener("beforeunload", () => {
  // 通知 Service Worker 页面正常关闭
  if (navigator.serviceWorker.controller) {
    navigator.serviceWorker.controller.postMessage({
      type: "page-close",
    });
  }
});
```

---

#### 方案二：load/beforeunload 标记法

**核心原理**：

- 页面加载时在 `sessionStorage` 中设置标记
- 页面正常卸载时清除标记
- 下次加载时检查标记是否存在，存在则说明上次崩溃

**完整实现**：

```js
class CrashMonitor {
  constructor() {
    this.CRASH_FLAG_KEY = "page_crash_flag";
    this.CRASH_INFO_KEY = "page_crash_info";
    this.init();
  }

  init() {
    // 1. 检查上次是否崩溃
    this.checkPreviousCrash();

    // 2. 设置当前页面标记
    this.setPageFlag();

    // 3. 监听页面卸载
    this.listenPageUnload();
  }

  checkPreviousCrash() {
    const crashFlag = sessionStorage.getItem(this.CRASH_FLAG_KEY);

    if (crashFlag) {
      // 发现崩溃标记，说明上次页面崩溃了
      const crashInfo = JSON.parse(
        sessionStorage.getItem(this.CRASH_INFO_KEY) || "{}"
      );

      console.error("检测到上次页面崩溃:", crashInfo);

      // 上报崩溃信息
      this.reportCrash({
        type: "page-crash",
        ...crashInfo,
        crashTime: Date.now(),
        userAgent: navigator.userAgent,
      });

      // 清除崩溃标记
      sessionStorage.removeItem(this.CRASH_FLAG_KEY);
      sessionStorage.removeItem(this.CRASH_INFO_KEY);
    }
  }

  setPageFlag() {
    // 设置页面加载标记
    sessionStorage.setItem(this.CRASH_FLAG_KEY, "true");

    // 记录页面信息
    const pageInfo = {
      pageUrl: window.location.href,
      loadTime: Date.now(),
      userId: this.getCurrentUserId(),
      referrer: document.referrer,
    };

    sessionStorage.setItem(this.CRASH_INFO_KEY, JSON.stringify(pageInfo));
  }

  listenPageUnload() {
    // 页面正常卸载时清除标记
    window.addEventListener("beforeunload", () => {
      sessionStorage.removeItem(this.CRASH_FLAG_KEY);
      sessionStorage.removeItem(this.CRASH_INFO_KEY);
    });

    // 页面隐藏时也清除（移动端）
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        sessionStorage.removeItem(this.CRASH_FLAG_KEY);
        sessionStorage.removeItem(this.CRASH_INFO_KEY);
      }
    });
  }

  reportCrash(crashInfo) {
    // 上报崩溃信息
    fetch("/api/crash-report", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(crashInfo),
    }).catch((err) => {
      console.error("崩溃上报失败:", err);
    });
  }

  getCurrentUserId() {
    // 获取当前用户 ID
    return localStorage.getItem("userId") || "anonymous";
  }
}

// 初始化崩溃监控
new CrashMonitor();
```

---

#### 两种方案对比

| 特性         | Service Worker 心跳检测    | load/beforeunload 标记法 |
| ------------ | -------------------------- | ------------------------ |
| 实时性       | 高（可实时检测）           | 低（下次访问才知道）     |
| 准确性       | 高                         | ⚠️ 中（可能误判）        |
| 实现复杂度   | ⚠️ 高                      | 低                       |
| 浏览器兼容性 | ⚠️ 需要支持 Service Worker | 好                       |
| 性能影响     | ⚠️ 有心跳开销              | 几乎无影响               |
| 移动端支持   | 好                         | ⚠️ 需特殊处理            |

---

#### 移动端特殊处理

**问题**：移动端页面进入后台时，可能被系统挂起或回收，但不算崩溃。

**解决方案**：

```js
class MobileCrashMonitor extends CrashMonitor {
  constructor() {
    super();
    this.isPageVisible = true;
    this.listenVisibilityChange();
  }

  listenVisibilityChange() {
    // 监听页面可见性变化
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        // 页面进入后台，清除崩溃标记
        this.isPageVisible = false;
        sessionStorage.removeItem(this.CRASH_FLAG_KEY);
      } else {
        // 页面回到前台，重新设置标记
        this.isPageVisible = true;
        this.setPageFlag();
      }
    });

    // 监听页面冻结（Page Lifecycle API）
    document.addEventListener("freeze", () => {
      sessionStorage.removeItem(this.CRASH_FLAG_KEY);
    });

    // 监听页面恢复
    document.addEventListener("resume", () => {
      this.setPageFlag();
    });
  }
}

// 使用
new MobileCrashMonitor();
```

---

#### 心跳间隔设置策略

```js
class AdaptiveHeartbeat {
  constructor() {
    this.baseInterval = 5000; // 基础间隔 5 秒
    this.maxInterval = 30000; // 最大间隔 30 秒
    this.currentInterval = this.baseInterval;
    this.init();
  }

  init() {
    this.startHeartbeat();
    this.adjustInterval();
  }

  startHeartbeat() {
    const sendHeartbeat = () => {
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
          type: "heartbeat",
          timestamp: Date.now(),
        });
      }

      // 使用当前间隔
      setTimeout(sendHeartbeat, this.currentInterval);
    };

    sendHeartbeat();
  }

  adjustInterval() {
    // 根据页面可见性调整心跳间隔
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        // 页面不可见，降低心跳频率
        this.currentInterval = this.maxInterval;
      } else {
        // 页面可见，恢复正常频率
        this.currentInterval = this.baseInterval;
      }
    });

    // 根据网络状态调整
    if ("connection" in navigator) {
      navigator.connection.addEventListener("change", () => {
        const { effectiveType } = navigator.connection;

        if (effectiveType === "slow-2g" || effectiveType === "2g") {
          // 慢速网络，降低频率
          this.currentInterval = this.maxInterval;
        } else {
          this.currentInterval = this.baseInterval;
        }
      });
    }
  }
}

new AdaptiveHeartbeat();
```

### 接口错误监控

接口监控的实现原理：针对浏览器内置的 `XMLHttpRequest` 和 `fetch` 对象，通过 **Monkey Patch (猴子补丁)** 或 **AOP (面向切片编程)** 重写原生方法，在请求发起前和响应完成后插入监控逻辑。

#### 1. XMLHttpRequest 监控实现

```js
function injectXHR() {
  const XMLHttpRequest = window.XMLHttpRequest;
  if (!XMLHttpRequest) return;

  const nativeOpen = XMLHttpRequest.prototype.open;
  const nativeSend = XMLHttpRequest.prototype.send;

  // 1. 劫持 open 方法获取请求配置（URL, Method）
  XMLHttpRequest.prototype.open = function (method, url, ...args) {
    this._monitor_data = {
      method,
      url,
      startTime: Date.now(),
      type: "xhr",
    };
    return nativeOpen.apply(this, [method, url, ...args]);
  };

  // 2. 劫持 send 方法监听结果
  XMLHttpRequest.prototype.send = function (body) {
    this._monitor_data.params = body;

    // 监听加载完成（loadend 事件包含完成、错误、中止的情况）
    this.addEventListener("loadend", function () {
      const { status, responseURL, response } = this;
      const duration = Date.now() - this._monitor_data.startTime;

      // 只记录错误或异常状态码（如 4xx, 5xx, 或网络中断 status=0）
      if (status === 0 || status >= 400) {
        reportError({
          ...this._monitor_data,
          status,
          duration,
          response:
            typeof response === "string"
              ? response.slice(0, 500)
              : "[Non-String Response]",
          timestamp: Date.now(),
        });
      }
    });

    return nativeSend.apply(this, [body]);
  };
}
```

#### 2. Fetch 监控实现

```js
function injectFetch() {
  if (!window.fetch) return;

  const nativeFetch = window.fetch;

  window.fetch = function (url, config = {}) {
    const startTime = Date.now();
    const method = config.method || "GET";

    return nativeFetch(url, config)
      .then((response) => {
        const duration = Date.now() - startTime;

        // 注意：fetch 只有在网络层失败（如断网）才 reject
        // 404/500 等状态码在 fetch 中被视为成功，需通过 response.ok 判断
        if (!response.ok) {
          const cloneRes = response.clone(); // ⚠️ 必须克隆，避免影响业务读取流
          cloneRes.text().then((text) => {
            reportError({
              type: "fetch",
              url,
              method,
              status: response.status,
              duration,
              response: text.slice(0, 500),
              timestamp: Date.now(),
            });
          });
        }
        return response;
      })
      .catch((error) => {
        // 捕获网络异常（跨域拦截、断网等）
        reportError({
          type: "fetch",
          url,
          method,
          status: "NETWORK_ERROR",
          message: error.message,
          timestamp: Date.now(),
        });
        throw error;
      });
  };
}
```

#### 3. 核心注意事项

- **防御循环触发**：在 `reportError` 内部发起的上报请求，**绝对不能**再被拦截器处理，否则会造成内存溢出或无限请求。通常通过检测特定的 `Header` 或 `URL` 过滤。
- **响应体克隆**：`fetch` 的 `Response` 是流式的，只能读取一次。监控代码必须调用 `.clone()`，否则业务代码在尝试读取数据时会报 "Body has already been consumed" 错误。
- **耗时计算**：从 `open/fetch` 开始计时，到 `loadend/resolve` 为止，这能准确反应接口性能。

---

## 错误捕获总结

下表对比了各种监控手段的覆盖能力和局限性：

| 异常分类              | 监听方法                           | 采集信息关键点                  | 局限性/注意点                                              |
| :-------------------- | :--------------------------------- | :------------------------------ | :--------------------------------------------------------- |
| **JS 运行时错误**     | `window.onerror`                   | 报错行号、列号、堆栈            | 必须设置跨域 CORS 才能看到具体报错信息                     |
| **异步 Promise 错误** | `unhandledrejection`               | `event.reason` (报错详情)       | 无法捕获被业务代码中 `.catch()` 处理掉的异常               |
| **静态资源加载失败**  | `window.addEventListener('error')` | `event.target` (加载失败的 DOM) | 资源错误不冒泡，必须在**捕获阶段**（第三个参数 true）监听  |
| **Vue 框架异常**      | `app.config.errorHandler`          | 组件名、生命周期钩子、Props     | 会屏蔽掉默认的控制台报错，建议内部重新打印 `console.error` |
| **页面崩溃 (Crash)**  | `Service Worker` + `心跳`          | 最后记录的时间戳 + 页面 URL     | 兼容性受限，标记法（sessionStorage）可作为兜底方案         |
| **接口请求异常**      | `劫持 XHR/Fetch`                   | 状态码、请求参数、响应体、耗时  | 必须正确处理响应流（clone）并防御死循环上报                |
| **Console 报错**      | `劫持 console.error`               | 业务手动埋点的错误信息          | 很多三方库会内部捕获并静默打印，劫持此处可做兜底           |
