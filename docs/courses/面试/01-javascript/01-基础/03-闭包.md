---
title: 闭包
author: DBAAZzz
date: 2025/11/18 22:34
categories:
  - 面试
tags:
  - 闭包
---

## 什么是闭包

**闭包**是指函数能够"记住"并访问其词法作用域（定义时的作用域），即使该函数在其词法作用域之外执行。

本质剖析：

- 闭包不是 JavaScript 特有的概念，而是词法作用域（Lexical Scope）的自然结果
- JavaScript 引擎通过作用域链（Scope Chain） 实现闭包：每个函数创建时会保存对其外部作用域的引用
- 闭包的内存表现：被闭包引用的变量不会被垃圾回收，形成"内存孤岛"

闭包的形成条件：

- 函数嵌套（内部函数引用外部函数的变量）
- 内部函数被返回或以某种方式保存
- 外部函数执行完毕后，其作用域链依然被保持

```javascript
function outer() {
  let count = 0; // 外部函数的变量

  function inner() {
    count++; // 内部函数访问外部变量
    console.log(count);
  }

  return inner;
}

const counter = outer(); // outer 执行完毕
counter(); // 1 - 但 count 变量仍然存在
counter(); // 2
counter(); // 3
```

## 闭包的核心特性

1. 数据私有化

```javascript
function createWallet() {
  let balance = 0; // 私有变量，外部无法直接访问

  return {
    deposit(amount) {
      balance += amount;
      return balance;
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
        return balance;
      }
      return "Insufficient funds";
    },
    getBalance() {
      return balance;
    },
  };
}

const myWallet = createWallet();
myWallet.deposit(100); // 100
console.log(myWallet.balance); // undefined - 无法直接访问
console.log(myWallet.getBalance()); // 100 - 只能通过方法访问
```

2. 状态保持

```javascript
function makeAdder(x) {
  return function (y) {
    return x + y; // x 被"记住"了
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12
```

## 现代前端中的闭包应用

1. React Hooks（最典型的应用）

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  // 事件处理函数形成闭包，捕获当前的 count 值
  const handleClick = () => {
    console.log("Current count:", count);
    setCount(count + 1);
  };

  // 闭包陷阱示例
  useEffect(() => {
    const timer = setInterval(() => {
      // 这里的 count 永远是初始值 0（闭包陷阱）
      console.log(count);
    }, 1000);

    return () => clearInterval(timer);
  }, []); // 空依赖数组

  return <button onClick={handleClick}>Count: {count}</button>;
}
```

React 的 useState 使用闭包在内部维护了一个状态存储系统，使得每个组件实例都能独立管理自己的状态。每次重新渲染时，闭包确保 React 记住 count 是更新后的值。

上面闭包陷阱分析：

```javascript
// 时间线：
// t0: 组件首次渲染，count = 0
//     useEffect 执行，创建定时器，回调函数闭包捕获 count = 0

// t1: 用户点击按钮，setCount(1)
//     组件重新渲染，count = 1
//     但 useEffect 因为依赖数组为空，不会重新执行
//     定时器中的回调函数仍然引用着旧的闭包（count = 0）

// t2: 用户点击按钮，setCount(2)
//     同样，定时器回调仍然看到 count = 0
```
