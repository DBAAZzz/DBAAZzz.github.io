---
title: 闭包
author: DBAAZzz
date: 2025/11/18 22:34
categories:
  - 面试
tags:
  - 闭包
---

## 什么是闭包

**闭包**是指函数能够"记住"并访问其词法作用域（定义时的作用域），即使该函数在其词法作用域之外执行。

面试回答：闭包是指函数能够访问其外部作用域中的变量，即使外部函数已经执行完毕。简单说，就是函数 + 它能访问的外部变量。

本质剖析：

- 闭包不是 JavaScript 特有的概念，而是词法作用域（Lexical Scope）的自然结果
- JavaScript 引擎通过作用域链（Scope Chain） 实现闭包：每个函数创建时会保存对其外部作用域的引用
- 闭包的内存表现：被闭包引用的变量不会被垃圾回收，形成"内存孤岛"

闭包的形成条件：

- 函数嵌套（内部函数引用外部函数的变量）
- 内部函数被返回或以某种方式保存
- 外部函数执行完毕后，其作用域链依然被保持

```javascript
function outer() {
  let count = 0 // 外部函数的变量

  function inner() {
    count++ // 内部函数访问外部变量
    console.log(count)
  }

  return inner
}

const counter = outer() // outer 执行完毕
counter() // 1 - 但 count 变量仍然存在
counter() // 2
counter() // 3
```

## 闭包的核心特性

1. 数据私有化

```javascript
function createWallet() {
  let balance = 0 // 私有变量，外部无法直接访问

  return {
    deposit(amount) {
      balance += amount
      return balance
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount
        return balance
      }
      return 'Insufficient funds'
    },
    getBalance() {
      return balance
    },
  }
}

const myWallet = createWallet()
myWallet.deposit(100) // 100
console.log(myWallet.balance) // undefined - 无法直接访问
console.log(myWallet.getBalance()) // 100 - 只能通过方法访问
```

2. 状态保持

```javascript
function makeAdder(x) {
  return function (y) {
    return x + y // x 被"记住"了
  }
}

const add5 = makeAdder(5)
const add10 = makeAdder(10)

console.log(add5(2)) // 7
console.log(add10(2)) // 12
```

## 现代前端中的闭包应用

1. React Hooks（最典型的应用）

```javascript
function Counter() {
  const [count, setCount] = useState(0)

  // 事件处理函数形成闭包，捕获当前的 count 值
  const handleClick = () => {
    console.log('Current count:', count)
    setCount(count + 1)
  }

  // 闭包陷阱示例
  useEffect(() => {
    const timer = setInterval(() => {
      // 这里的 count 永远是初始值 0（闭包陷阱）
      console.log(count)
    }, 1000)

    return () => clearInterval(timer)
  }, []) // 空依赖数组

  return <button onClick={handleClick}>Count: {count}</button>
}
```

React 的 useState 使用闭包在内部维护了一个状态存储系统，使得每个组件实例都能独立管理自己的状态。每次重新渲染时，闭包确保 React 记住 count 是更新后的值。

上面闭包陷阱分析：

```javascript
// 时间线：
// t0: 组件首次渲染，count = 0
//     useEffect 执行，创建定时器，回调函数闭包捕获 count = 0

// t1: 用户点击按钮，setCount(1)
//     组件重新渲染，count = 1
//     但 useEffect 因为依赖数组为空，不会重新执行
//     定时器中的回调函数仍然引用着旧的闭包（count = 0）

// t2: 用户点击按钮，setCount(2)
//     同样，定时器回调仍然看到 count = 0
```

2. 数据私有化

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance // 私有变量，外部无法直接访问

  return {
    deposit(amount) {
      balance += amount
      return balance
    },
    withdraw(amount) {
      if (amount > balance) {
        return '余额不足'
      }
      balance -= amount
      return balance
    },
    getBalance() {
      return balance
    },
  }
}

const account = createBankAccount(1000)
account.deposit(500) // 1500
account.withdraw(200) // 1300
console.log(account.balance) // undefined（外部无法直接访问）
```

3. 节流防抖

```javascript
function throttle(fn, delay) {
  let lastTime = 0

  return function (...args) {
    const now = Date.now()
    if (now - lastTime >= delay) {
      lastTime = now
      fn.apply(this, args)
    }
  }
}

function debounce(fn, delay) {
  let timer = null // 闭包保存定时器ID

  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}
```

4. 单例模式

```javascript
function createSingleton(className) {
  let instance

  return function (...args) {
    if (!instance) {
      instance = new className(...args)
    }
    return instance
  }
}

class Database {
  constructor(config) {
    this.config = config
    console.log('数据库连接创建')
  }
}

const getDatabase = createSingleton(Database)
const db1 = getDatabase({ host: 'localhost' })
const db2 = getDatabase({ host: 'other' })
console.log(db1 === db2) // true，只创建一次
```

5. 柯里化

```javascript
// 普通函数
function add(a, b, c) {
  return a + b + c
}

// 柯里化版本 - 依赖闭包保存参数
function curryAdd(a) {
  // 第一次调用：闭包保存 a
  return function (b) {
    // 第二次调用：闭包保存 b，还能访问 a
    return function (c) {
      // 第三次调用：能访问 a 和 b
      return a + b + c
    }
  }
}

const result = curryAdd(1)(2)(3) // 6
```
