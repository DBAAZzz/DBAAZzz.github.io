---
title: 批量更新机制
author: DBAAZzz
date: 2024/12/29
categories:
  - vue3
tags:
  - reactivity
  - source-code
---

好的，Vue 的批量更新机制确实是响应式系统的核心。让我详细拆解一下。

## 核心机制概述

Vue 使用了**嵌套计数器 + 延迟队列**的方式实现批量更新，确保同一 tick 内的多次变更只触发一次副作用执行。

---

## 关键数据结构

```typescript
// packages/reactivity/src/effect.ts#L236-L238
let batchDepth = 0; // 批量操作的嵌套深度
let batchedSub: Subscriber | undefined; // 普通副作用队列
let batchedComputed: Subscriber | undefined; // 计算属性队列
```

这三个变量是批量更新的基础：

- `batchDepth`：用于支持嵌套的批量操作（比如在 watch 中触发另一个响应式更新）
- `batchedSub`：链表头，存储所有待执行的普通副作用
- `batchedComputed`：单独队列，优先处理计算属性

---

## 标志位去重机制

```typescript
// packages/reactivity/src/effect.ts#L136-L144
notify(): void {
  if (
    this.flags & EffectFlags.RUNNING &&
    !(this.flags & EffectFlags.ALLOW_RECURSE)
  ) {
    return
  }
  if (!(this.flags & EffectFlags.NOTIFIED)) {
    batch(this)
  }
}
```

关键点：

1. `NOTIFIED` 标志位：每个副作用被通知后设置此标志，避免重复入队
2. `RUNNING` 检查：防止递归触发（除非设置了 `ALLOW_RECURSE`）

---

## 批量操作边界

```typescript
// packages/reactivity/src/effect.ts#L251-L260
export function startBatch(): void {
  batchDepth++;
}

export function endBatch(): void {
  if (--batchDepth > 0) {
    return;
  }
  // ... 执行队列中的副作用
}
```

`startBatch()`/`endBatch()` 是配对使用的：

- 递增 `batchDepth` 标记进入批量模式
- 只有当 `batchDepth` 降为 0 时，才会真正执行副作用

---

## 入队逻辑

```typescript
// packages/reactivity/src/effect.ts#L240-L249
export function batch(sub: Subscriber, isComputed = false): void {
  sub.flags |= EffectFlags.NOTIFIED;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
```

使用链表结构，避免数组遍历开销：

1. 设置 `NOTIFIED` 标志位去重
2. 计算属性单独放入 `batchedComputed` 队列
3. 普通副作用放入 `batchedSub` 队列

---

## 触发流程：从数据变更到批量执行

当响应式对象发生变化时：

```typescript
// packages/reactivity/src/dep.ts#L294-L390
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
): void {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }

  const run = (dep: Dep | undefined) => {
    if (dep) {
      dep.trigger(); // 调用每个依赖的 trigger
    }
  };

  startBatch(); // ⭐ 开始批量操作

  // ... 找到所有相关的 dep 并调用 run(dep)

  endBatch(); // ⭐ 结束批量操作，执行队列
}
```

关键点：

1. `startBatch()` 在 `trigger()` 开始时调用
2. 找到所有相关的 `Dep` 对象，调用它们的 `trigger()` 方法
3. `endBatch()` 在所有副作用收集完后调用，执行队列

---

## Dep 的通知机制

```typescript
// packages/reactivity/src/dep.ts#L167-L205
trigger(debugInfo?: DebuggerEventExtraInfo): void {
  this.version++
  globalVersion++
  this.notify(debugInfo)
}

notify(debugInfo?: DebuggerEventExtraInfo): void {
  startBatch()  // ⭐ Dep 也会开启批量操作
  try {
    // 调试钩子
    if (__DEV__) {
      for (let head = this.subsHead; head; head = head.nextSub) {
        if (head.sub.onTrigger && !(head.sub.flags & EffectFlags.NOTIFIED)) {
          head.sub.onTrigger(/*...*/)
        }
      }
    }
    // 反向遍历通知副作用（正向执行）
    for (let link = this.subs; link; link = link.prevSub) {
      if (link.sub.notify()) {
        // 计算属性需要额外通知它的依赖
        ;(link.sub as ComputedRefImpl).dep.notify()
      }
    }
  } finally {
    endBatch()
  }
}
```

这里有两层 `startBatch()`/`endBatch()`：

1. `trigger()` 函数外层的批量操作
2. `Dep.notify()` 内层的批量操作

这样设计的好处：即使一个 `Dep` 包含多个副作用，它们也会被批量处理。

---

## 执行队列

```typescript
// packages/reactivity/src/effect.ts#L258-L300
export function endBatch(): void {
  if (--batchDepth > 0) {
    return;
  }

  // 1. 先处理计算属性队列
  if (batchedComputed) {
    let e: Subscriber | undefined = batchedComputed;
    batchedComputed = undefined;
    while (e) {
      const next: Subscriber | undefined = e.next;
      e.next = undefined;
      e.flags &= ~EffectFlags.NOTIFIED; // 清除 NOTIFIED 标志
      e = next;
    }
  }

  // 2. 再处理普通副作用队列
  let error: unknown;
  while (batchedSub) {
    let e: Subscriber | undefined = batchedSub;
    batchedSub = undefined;
    while (e) {
      const next: Subscriber | undefined = e.next;
      e.next = undefined;
      e.flags &= ~EffectFlags.NOTIFIED;
      if (e.flags & EffectFlags.ACTIVE) {
        try {
          (e as ReactiveEffect).trigger(); // 执行副作用的 trigger
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }

  if (error) throw error;
}
```

执行顺序：

1. 先清空 `batchedComputed` 队列（计算属性优先级更高）
2. 再执行 `batchedSub` 队列中的副作用
3. 执行时调用 `ReactiveEffect.trigger()`

---

## ReactiveEffect 的 trigger 方法

```typescript
// packages/reactivity/src/effect.ts#L195-L204
trigger(): void {
  if (this.flags & EffectFlags.PAUSED) {
    pausedQueueEffects.add(this)
  } else if (this.scheduler) {
    this.scheduler()  // 使用自定义调度器（如 nextTick）
  } else {
    this.runIfDirty()  // 同步执行
  }
}
```

三种执行方式：

1. **PAUSED**：副作用暂停，加入 `pausedQueueEffects`
2. **有 scheduler**：使用调度器（通常是 `queueJob` + 微任务）
3. **默认**：立即执行 `runIfDirty()`

---

## 与浏览器事件循环的关系

Vue 的批量更新本身**不依赖**浏览器事件循环，它是在同步代码中完成的。真正的"Tick"概念来自调度器：

```javascript
// packages/runtime-core/src/scheduler.ts
const queue: SchedulerJob[] = [];
let isFlushing = false;

export function queueJob(job: SchedulerJob) {
  if (!queue.includes(job)) {
    queue.push(job);
    queueFlush();
  }
}

function queueFlush() {
  if (!isFlushing) {
    isFlushing = true;
    Promise.resolve().then(flushJobs); // 使用微任务
  }
}
```

如果副作用配置了 `scheduler`，会被放入队列并在微任务中执行，这样多个副作用会在同一个微任务 tick 中批量执行。

---

## 完整流程示例

```javascript
const state = reactive({ count: 0 });

effect(() => {
  console.log("count:", state.count);
});

// 同一个 tick 内多次修改
state.count++; // trigger() -> startBatch() -> 收集副作用 -> endBatch()
state.count++; // trigger() -> startBatch() -> NOTIFIED 标志已设置，跳过 -> endBatch()
state.count++; // 同上

// tick 结束，endBatch() 执行队列，副作用只执行一次
// 输出: count: 3
```

---

## 总结

Vue 的批量更新机制：

1. **计数器控制**：`batchDepth` 支持嵌套批量操作
2. **标志位去重**：`NOTIFIED` 防止副作用重复入队
3. **链表队列**：高效收集和遍历副作用
4. **两层批量**：`trigger()` 和 `Dep.notify()` 都使用批量操作
5. **计算属性优先**：`batchedComputed` 单独队列先执行
6. **调度器扩展**：通过 `scheduler` 支持微任务级别的批量
