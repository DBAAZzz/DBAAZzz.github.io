import{_ as s,o as a,c as n,X as l}from"./chunks/framework.6625828e.js";const D=JSON.parse('{"title":"栈内存和堆内存","description":"","frontmatter":{"title":"栈内存和堆内存","author":"DBAAZzz","date":"2025/06/06 17:00","categories":["面试"],"tags":["requestAnimationFrame"]},"headers":[],"relativePath":"courses/面试/01-javascript/03-栈内存和堆内存.md","filePath":"courses/面试/01-javascript/03-栈内存和堆内存.md","lastUpdated":1749208485000}'),o={name:"courses/面试/01-javascript/03-栈内存和堆内存.md"},p=l(`<h3 id="核心比喻-书桌与图书馆" tabindex="-1">核心比喻：书桌与图书馆 <a class="header-anchor" href="#核心比喻-书桌与图书馆" aria-label="Permalink to &quot;核心比喻：书桌与图书馆&quot;">​</a></h3><p>为了方便理解，我们可以做一个简单的比喻：</p><ul><li><strong>栈内存 (Stack)</strong>：就像你书桌上的一小块整洁区域。你处理当前任务时，会把需要的工具（比如一支笔、一张便签纸）直接放在上面。它的空间有限，但拿取东西非常快。当你完成任务，就会立刻把这些东西清理掉。</li><li><strong>堆内存 (Heap)</strong>：就像一个巨大的图书馆。当你需要一本很厚的参考书时，你不会把它一直摊在书桌上，而是去图书馆找到它，然后在你的书桌便签纸上记下它的<strong>书架号</strong>。图书馆空间巨大，可以存放各种复杂、大型的书籍。</li></ul><hr><h3 id="栈内存和堆内存的区别" tabindex="-1">栈内存和堆内存的区别 <a class="header-anchor" href="#栈内存和堆内存的区别" aria-label="Permalink to &quot;栈内存和堆内存的区别&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">栈内存 (Stack)</th><th style="text-align:left;">堆内存 (Heap)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>存储内容</strong></td><td style="text-align:left;"><strong>原始类型 (Primitive Types)</strong>：<code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>null</code>, <code>undefined</code>, <code>Symbol</code>, <code>BigInt</code>。 &lt;br&gt;&lt;br&gt; <strong>对象的引用 (Reference)</strong>：指向堆内存中对象的地址（“书架号”）。</td><td style="text-align:left;"><strong>引用类型 (Reference Types)</strong>：<code>Object</code> (包括普通对象、数组 <code>Array</code>、函数 <code>Function</code> 等)。</td></tr><tr><td style="text-align:left;"><strong>数据结构</strong></td><td style="text-align:left;"><strong>后进先出 (LIFO)</strong>。就像一摞盘子，最后放上去的盘子最先被取走。与函数调用栈的执行顺序完美契合。</td><td style="text-align:left;"><strong>无序</strong>。像一个仓库，数据没有固定的排列顺序，可以动态地申请和释放空间。</td></tr><tr><td style="text-align:left;"><strong>访问速度</strong></td><td style="text-align:left;"><strong>非常快</strong>。内存地址是连续的，大小是固定的，CPU 通过一个简单的指针移动就能分配和释放内存。</td><td style="text-align:left;"><strong>相对较慢</strong>。因为需要先从栈中读取引用地址，然后再根据地址去不连续的内存空间中找到目标数据。</td></tr><tr><td style="text-align:left;"><strong>生命周期</strong></td><td style="text-align:left;">当函数执行时，其内部的变量会被压入栈中；当<strong>函数执行完毕</strong>，这些变量就会被自动弹出并销毁。</td><td style="text-align:left;">当一个对象被创建时，它会被分配到堆内存中。它的生命周期由 JavaScript 的<strong>垃圾回收机制 (Garbage Collection)</strong> 管理。只有当没有任何引用指向这个对象时，它才会被回收。</td></tr><tr><td style="text-align:left;"><strong>空间大小</strong></td><td style="text-align:left;"><strong>固定且较小</strong>。</td><td style="text-align:left;"><strong>动态且较大</strong>。可以根据需要动态地分配内存。</td></tr></tbody></table><h4 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-label="Permalink to &quot;代码示例&quot;">​</a></h4><p>让我们用一段代码来形象化这个过程：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#F47067;">function</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">processData</span><span style="color:#ADBAC7;">() {</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">let</span><span style="color:#ADBAC7;"> age </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#6CB6FF;">30</span><span style="color:#ADBAC7;">; </span><span style="color:#768390;">// 原始类型</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">let</span><span style="color:#ADBAC7;"> name </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#96D0FF;">&quot;Alice&quot;</span><span style="color:#ADBAC7;">; </span><span style="color:#768390;">// 原始类型</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">let</span><span style="color:#ADBAC7;"> user </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#768390;">// 引用类型</span></span>
<span class="line"><span style="color:#ADBAC7;">    id: </span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">,</span></span>
<span class="line"><span style="color:#ADBAC7;">    email: </span><span style="color:#96D0FF;">&quot;alice@example.com&quot;</span><span style="color:#ADBAC7;">,</span></span>
<span class="line"><span style="color:#ADBAC7;">  };</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">let</span><span style="color:#ADBAC7;"> anotherUser </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> user; </span><span style="color:#768390;">// 引用赋值</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCBDFB;">processData</span><span style="color:#ADBAC7;">();</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#AB5959;">function</span><span style="color:#393A34;"> </span><span style="color:#59873A;">processData</span><span style="color:#999999;">()</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">let</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">age</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">30</span><span style="color:#999999;">;</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">// 原始类型</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">let</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">name</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">Alice</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">;</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">// 原始类型</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">let</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">user</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">    </span><span style="color:#A0ADA0;">// 引用类型</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#998418;">id</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">1</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#998418;">email</span><span style="color:#999999;">:</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">alice@example.com</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">};</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">let</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">anotherUser</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">user</span><span style="color:#999999;">;</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">// 引用赋值</span></span>
<span class="line"><span style="color:#999999;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#59873A;">processData</span><span style="color:#999999;">();</span></span></code></pre></div><p>当 <code>processData()</code> 函数被调用时，内存中会发生以下情况：</p><ol><li><p><strong>栈内存 (Stack)</strong>:</p><ul><li>为 <code>processData</code> 函数创建一个执行上下文（一个独立的内存空间）。</li><li>在其中创建变量 <code>age</code>，并直接存储它的值 <code>30</code>。</li><li>创建变量 <code>name</code>，并直接存储它的值 <code>&quot;Alice&quot;</code>。</li><li>创建变量 <code>user</code>，它需要存储一个对象。此时，JavaScript 引擎会在<strong>堆内存</strong>中创建这个对象 <code>{ id: 1, ... }</code>，并把这个对象在堆中的内存地址（比如 <code>0x101</code>）赋值给栈中的 <code>user</code> 变量。</li><li>创建变量 <code>anotherUser</code>。因为 <code>user</code> 存的是一个地址，所以 <code>anotherUser = user</code> 这条语句只是把 <code>0x101</code> 这个地址又复制了一份给了 <code>anotherUser</code>。</li></ul></li><li><p><strong>堆内存 (Heap)</strong>:</p><ul><li>分配一块内存（地址为 <code>0x101</code>），用于存储对象 <code>{ id: 1, email: &quot;alice@example.com&quot; }</code>。</li></ul></li></ol><p><strong>图示：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#adbac7;">栈内存 (STACK)                         堆内存 (HEAP)</span></span>
<span class="line"><span style="color:#adbac7;">┌───────────────────────────┐         ┌───────────────────────────────────────┐</span></span>
<span class="line"><span style="color:#adbac7;">│                           │         │                                       │</span></span>
<span class="line"><span style="color:#adbac7;">│ anotherUser: 0x101        ├─────────► (地址 0x101)                            │</span></span>
<span class="line"><span style="color:#adbac7;">│ user:        0x101        │         │ {                                     │</span></span>
<span class="line"><span style="color:#adbac7;">│ name:        &quot;Alice&quot;      │         │    id: 1,                             │</span></span>
<span class="line"><span style="color:#adbac7;">│ age:         30           │         │    email: &quot;alice@example.com&quot;         │</span></span>
<span class="line"><span style="color:#adbac7;">│                           │         │ }                                     │</span></span>
<span class="line"><span style="color:#adbac7;">└───────────────────────────┘         └───────────────────────────────────────┘</span></span>
<span class="line"><span style="color:#adbac7;">  (processData 执行上下文)</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#393a34;">栈内存 (STACK)                         堆内存 (HEAP)</span></span>
<span class="line"><span style="color:#393a34;">┌───────────────────────────┐         ┌───────────────────────────────────────┐</span></span>
<span class="line"><span style="color:#393a34;">│                           │         │                                       │</span></span>
<span class="line"><span style="color:#393a34;">│ anotherUser: 0x101        ├─────────► (地址 0x101)                            │</span></span>
<span class="line"><span style="color:#393a34;">│ user:        0x101        │         │ {                                     │</span></span>
<span class="line"><span style="color:#393a34;">│ name:        &quot;Alice&quot;      │         │    id: 1,                             │</span></span>
<span class="line"><span style="color:#393a34;">│ age:         30           │         │    email: &quot;alice@example.com&quot;         │</span></span>
<span class="line"><span style="color:#393a34;">│                           │         │ }                                     │</span></span>
<span class="line"><span style="color:#393a34;">└───────────────────────────┘         └───────────────────────────────────────┘</span></span>
<span class="line"><span style="color:#393a34;">  (processData 执行上下文)</span></span></code></pre></div><p>当 <code>processData()</code> 函数执行结束后，栈上的所有内容（<code>age</code>, <code>name</code>, <code>user</code>, <code>anotherUser</code>）会被立即清空。堆中的对象由于暂时没有引用指向它，会在稍后被垃圾回收器清理。</p><hr><h3 id="class-的静态属性存放在哪里" tabindex="-1">Class 的静态属性存放在哪里？ <a class="header-anchor" href="#class-的静态属性存放在哪里" aria-label="Permalink to &quot;Class 的静态属性存放在哪里？&quot;">​</a></h3><p><strong>答案：存放在堆内存 (Heap) 中。</strong></p><p><strong>原因如下：</strong></p><ol><li><p><strong>Class 是函数的语法糖</strong>：在 JavaScript 中，<code>class</code> 本质上是构造函数的一种更优雅的写法（“语法糖”）。当你定义一个类时，你实际上是在创建一个函数对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#F47067;">class</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">Dog</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">scientificName</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#96D0FF;">&quot;Canis lupus familiaris&quot;</span><span style="color:#ADBAC7;">; </span><span style="color:#768390;">// 静态属性</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">constructor</span><span style="color:#ADBAC7;">(</span><span style="color:#F69D50;">name</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.name </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> name; </span><span style="color:#768390;">// 实例属性</span></span>
<span class="line"><span style="color:#ADBAC7;">  }</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"><span style="color:#768390;">// 上面的代码在底层行为上类似于：</span></span>
<span class="line"><span style="color:#F47067;">function</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Dog</span><span style="color:#ADBAC7;">(</span><span style="color:#F69D50;">name</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.name </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> name;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"><span style="color:#ADBAC7;">Dog.scientificName </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#96D0FF;">&quot;Canis lupus familiaris&quot;</span><span style="color:#ADBAC7;">;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#AB5959;">class</span><span style="color:#393A34;"> </span><span style="color:#2E8F82;">Dog</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">static</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">scientificName</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">Canis lupus familiaris</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">;</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">// 静态属性</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#AB5959;">constructor</span><span style="color:#999999;">(</span><span style="color:#B07D48;">name</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">    </span><span style="color:#A65E2B;">this</span><span style="color:#999999;">.</span><span style="color:#B07D48;">name</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">name</span><span style="color:#999999;">;</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">// 实例属性</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#A0ADA0;">// 上面的代码在底层行为上类似于：</span></span>
<span class="line"><span style="color:#AB5959;">function</span><span style="color:#393A34;"> </span><span style="color:#59873A;">Dog</span><span style="color:#999999;">(</span><span style="color:#B07D48;">name</span><span style="color:#999999;">)</span><span style="color:#393A34;"> </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#A65E2B;">this</span><span style="color:#999999;">.</span><span style="color:#B07D48;">name</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">name</span><span style="color:#999999;">;</span></span>
<span class="line"><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#B07D48;">Dog</span><span style="color:#999999;">.</span><span style="color:#B07D48;">scientificName</span><span style="color:#393A34;"> </span><span style="color:#999999;">=</span><span style="color:#393A34;"> </span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">Canis lupus familiaris</span><span style="color:#B5695999;">&quot;</span><span style="color:#999999;">;</span></span></code></pre></div></li><li><p><strong>函数是对象</strong>：在 JavaScript 中，函数是“一等公民”，这意味着它们本身就是一种特殊的对象。</p></li><li><p><strong>对象存储在堆内存中</strong>：正如我们前面所说，所有的对象（包括函数对象）都存储在堆内存中。</p></li></ol><p><strong>结论：</strong></p><ul><li><code>class Dog</code> 这个定义本身创建了一个 <code>Dog</code> 构造函数对象，这个<strong>函数对象被存储在堆内存</strong>中。</li><li>静态属性 (<code>static scientificName</code>) 是直接附加在这个 <code>Dog</code> 构造函数对象上的属性。</li><li>因此，<strong>静态属性作为其所属的类（函数对象）的一部分，自然也存放在堆内存中</strong>。</li></ul><p>当你访问 <code>Dog.scientificName</code> 时，你是在访问堆内存中 <code>Dog</code> 这个函数对象的 <code>scientificName</code> 属性。而当你创建一个实例 <code>const myDog = new Dog(&#39;Buddy&#39;)</code> 时，<code>myDog</code> 这个实例对象也是一个新对象，它被存放在堆内存的另一个位置，它拥有自己的 <code>name</code> 属性，但它本身不直接包含 <code>scientificName</code> 这个静态属性。</p>`,22),e=[p];function t(c,r,i,y,d,A){return a(),n("div",null,e)}const B=s(o,[["render",t]]);export{D as __pageData,B as default};
