import{_ as e,o as a,c as t,X as l}from"./chunks/framework.6625828e.js";const b=JSON.parse('{"title":"前端性能","description":"","frontmatter":{"title":"前端性能","author":"DBAAZzz","date":"2025/11/20 15:40","categories":["面试"],"tags":["前端性能"]},"headers":[],"relativePath":"courses/面试/03-性能优化/01-前端性能优化.md","filePath":"courses/面试/03-性能优化/01-前端性能优化.md","lastUpdated":1763725679000}'),i={name:"courses/面试/03-性能优化/01-前端性能优化.md"},o=l('<h2 id="渲染优化" tabindex="-1">渲染优化 <a class="header-anchor" href="#渲染优化" aria-label="Permalink to &quot;渲染优化&quot;">​</a></h2><p>核心目标： 减少白屏时间，保持页面流畅（FPS 60），减少浏览器渲染管线的负担。</p><h3 id="回流-reflow-vs-重绘-repaint" tabindex="-1">回流 (Reflow) vs 重绘 (Repaint) <a class="header-anchor" href="#回流-reflow-vs-重绘-repaint" aria-label="Permalink to &quot;回流 (Reflow) vs 重绘 (Repaint)&quot;">​</a></h3><ul><li>回流 (Reflow/Layout)： 元素的几何属性（宽、高、位置）发生变化，浏览器需要重新计算布局。开销巨大。</li><li>重绘 (Repaint)： 元素外观（颜色、背景）变化，不影响布局。开销较小。</li></ul><p><strong>回流必将引起重绘，而重绘不一定引起回流。</strong></p><table><thead><tr><th>特性</th><th>回流 (Reflow)</th><th>重绘 (Repaint)</th></tr></thead><tbody><tr><td>触发条件</td><td>宽高、位置、Display (显隐)、字体大小、窗口 resize</td><td>颜色 (color)、背景 (background)、可见性 (visibility)</td></tr><tr><td>性能开销</td><td>极大 (可能波及全局)</td><td>较小 (通常只影响局部)</td></tr><tr><td>渲染流水线</td><td>DOM Tree → Render Tree → <strong>Layout</strong> → Paint</td><td>DOM Tree → Render Tree → <strong>Paint</strong></td></tr></tbody></table><h4 id="优化策略" tabindex="-1">优化策略 <a class="header-anchor" href="#优化策略" aria-label="Permalink to &quot;优化策略&quot;">​</a></h4><ul><li><p>读写分离：避免强制同步布局，不要你在读写 DOM 属性时交替进行。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>浏览器通常会有一个渲染队列，它会把多次 DOM 修改攒在一起，一次性执行（批量优化）。但是，如果你在修改样式后，立刻读取几何属性，浏览器为了给你返回正确的值，会被迫打断队列，立即执行回流</p></div></li><li><p>使用 CSS <code>Transform</code> 和 <code>Opacity</code>：它们可以跳过回流和重绘，直接在合成线程（Compositor Thread）处理，通常由 GPU 加速。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>举例说明：</p><ul><li>改变 <code>left</code> / <code>top</code>: 触发 Reflow + Repaint。 流程: JS -&gt; Style -&gt; Layout -&gt; Paint -&gt; Composite</li><li>改变 <code>transform</code>: <code>translate</code>: 既不触发 Reflow 也不触发 Repaint（在主线程），它直接交给 GPU 处理合成。 优化流程: JS -&gt; Style -&gt; Composite</li></ul></div></li><li><p>DOM 操作优化：避免频繁操作 DOM</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>使用 DocumentFragment 批量插入 DOM。</li><li><code>display: none</code>：元素从 Render Tree 中被移除。触发回流 (Reflow)。</li><li><code>visibility: hidden</code>: 元素还在 Render Tree 中，只是看不见（占据空间）。只触发重绘 (Repaint)。</li></ul></div></li></ul><h3 id="关键渲染路径-critical-rendering-path" tabindex="-1">关键渲染路径 (Critical Rendering Path) <a class="header-anchor" href="#关键渲染路径-critical-rendering-path" aria-label="Permalink to &quot;关键渲染路径 (Critical Rendering Path)&quot;">​</a></h3><h3 id="虚拟列表" tabindex="-1">虚拟列表 <a class="header-anchor" href="#虚拟列表" aria-label="Permalink to &quot;虚拟列表&quot;">​</a></h3><h4 id="什么是关键渲染路径" tabindex="-1">什么是关键渲染路径？ <a class="header-anchor" href="#什么是关键渲染路径" aria-label="Permalink to &quot;什么是关键渲染路径？&quot;">​</a></h4><p>浏览器将代码渲染为像素的步骤：</p><ol><li>HTML → DOM (文档对象模型)</li><li>CSS → CSSOM (CSS 对象模型)</li><li>DOM + CSSOM → Render Tree (渲染树)</li><li>Layout (布局)</li><li>Paint (绘制)</li></ol><h4 id="核心优化策略" tabindex="-1">核心优化策略 <a class="header-anchor" href="#核心优化策略" aria-label="Permalink to &quot;核心优化策略&quot;">​</a></h4><ul><li>优化 CSS（消除渲染阻塞）：CSS 是渲染阻塞资源 (Render Blocking)。构建 Render Tree 必须等待 CSSOM 构建完成。如果没有 CSS，浏览器通常会白屏。 <ul><li>内联关键 CSS。将首屏可见区域的 CSS 直接写在 HTML 的 <code>&lt;style&gt;</code> 标签中</li><li>推迟非关键 CSS。对于首屏用不到的样式，使用 <code>rel=&quot;preload&quot;</code> 或在底部加载。</li></ul></li><li>优化 JavaScript（消除解析阻塞）：JS 是解析阻塞资源 (Parser Blocking)，浏览器解析 HTML 遇到 <code>&lt;script&gt;</code> 时，会暂停解析 DOM，去下载并执行 JS。 <ul><li>使用 defer 和 async</li><li>脚本后置：将<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>之前（旧方案，现在更推荐 defer）</li></ul></li><li>利用资源提示 (Resource Hints)</li></ul><h4 id="cssom-构建会阻塞-js-执行" tabindex="-1">CSSOM 构建会阻塞 JS 执行 <a class="header-anchor" href="#cssom-构建会阻塞-js-执行" aria-label="Permalink to &quot;CSSOM 构建会阻塞 JS 执行&quot;">​</a></h4><p>如果存在尚未完整构建的 CSSOM（即正在加载或解析的 CSS），浏览器会强制等待 CSSOM 构建完成后，再执行 JavaScript。</p><p>原因：JavaScript 有可能会去读取或修改元素的样式。</p><p>为了避免竞态条件和不一致的渲染结果，浏览器采取了最保守的策略：<strong>只要后面有 JS 要执行，并且前面有 CSS 还在处理，那就等 CSS 处理完。</strong></p><hr><h2 id="cpu-优化" tabindex="-1">CPU 优化 <a class="header-anchor" href="#cpu-优化" aria-label="Permalink to &quot;CPU 优化&quot;">​</a></h2><p>核心目标： 避免主线程（Main Thread）阻塞，保证交互响应速度。</p><h3 id="避免长任务" tabindex="-1">避免长任务 <a class="header-anchor" href="#避免长任务" aria-label="Permalink to &quot;避免长任务&quot;">​</a></h3><p>浏览器的 GUI 渲染线程 和 JS 引擎线程 是互斥的。简单说，JS 跑久了，页面就卡死不动了。</p><p>优化目标：避免 <code>Long Tasks</code> (长任务)。</p><h4 id="优化策略-1" tabindex="-1">优化策略 <a class="header-anchor" href="#优化策略-1" aria-label="Permalink to &quot;优化策略&quot;">​</a></h4><ul><li><code>Web Workers</code>：将图像处理、大文件加密、复杂数学计算等耗时操作移到 <code>Worker</code> 线程，不阻塞主线程 UI。</li><li>时间切片 (<code>Time Slicing</code>) <ul><li>(React Fiber 的核心理念) 将一个大任务拆分成多个小任务，在浏览器空闲时执行（利用 <code>requestIdleCallback</code> 或 <code>scheduler</code>）。</li></ul></li></ul><h3 id="事件处理与算法" tabindex="-1">事件处理与算法 <a class="header-anchor" href="#事件处理与算法" aria-label="Permalink to &quot;事件处理与算法&quot;">​</a></h3><ul><li>防抖 (Debounce) 与 节流 (Throttle)： <ul><li>场景：滚动监听、窗口缩放、搜索框输入。</li><li>作用：限制高频事件触发 JS 的频率，减少 CPU 消耗。</li></ul></li><li>算法复杂度： 避免在循环中进行 <code>O(n^2)</code> 的查找，改用 Map/Object 进行 <code>O(1)</code> 查找。</li></ul><hr><h2 id="内存优化" tabindex="-1">内存优化 <a class="header-anchor" href="#内存优化" aria-label="Permalink to &quot;内存优化&quot;">​</a></h2><p>核心目标： 防止内存泄漏 (Memory Leaks)，降低内存峰值，避免页面崩溃。</p><h3 id="内存泄漏场景" tabindex="-1">内存泄漏场景 <a class="header-anchor" href="#内存泄漏场景" aria-label="Permalink to &quot;内存泄漏场景&quot;">​</a></h3><ul><li>未清理的全局变量： 意外创建的全局变量无法被回收。</li><li>被遗忘的定时器/监听器： 组件销毁（Unmount）时，没有清除 <code>setInterval</code> 或 <code>window.addEventListener</code>。</li><li>闭包 (Closures)： 不当使用闭包导致外部作用域变量无法释放。</li><li>分离的 DOM 节点 (Detached DOM)： JS 变量引用了已经从 DOM 树中移除的节点，导致整个节点树无法回收。</li></ul><h3 id="数据存储优化" tabindex="-1">数据存储优化 <a class="header-anchor" href="#数据存储优化" aria-label="Permalink to &quot;数据存储优化&quot;">​</a></h3><ul><li>弱引用 (WeakMap / WeakSet)： <ul><li>如果键（Key）是对象，当该对象在其他地方没有引用时，WeakMap 不会阻止垃圾回收（GC）。</li><li>场景： 存储 DOM 节点的元数据，防止 DOM 移除后内存泄漏。</li></ul></li><li>及时置空： 大对象使用完后，手动赋值 <code>null</code>（如 <code>largeData = null</code>），帮助 GC 识别。</li></ul>',36),r=[o];function d(c,n,s,h,u,p){return a(),t("div",null,r)}const m=e(i,[["render",d]]);export{b as __pageData,m as default};
